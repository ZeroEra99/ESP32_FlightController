
--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\server.py ---

from flask import Flask, jsonify, request, render_template_string
from datetime import datetime
from zeroconf import ServiceInfo, Zeroconf
import socket
import threading
import os
import signal

app = Flask(__name__)

# Variabili per salvare i log e i dati ricevuti
server_logs = []   # Log disponibili su /get_logs
display_logs = []  # Log visibili su /logs

server_data = []     # Dati numerici disponibili su /get_data_logs

# Variabile per il controllo dell'arresto
shutdown_signal = False

# Funzione per registrare il servizio mDNS
def start_mdns_service():
    hostname = socket.gethostname()
    local_ip = socket.gethostbyname(hostname)
    service_info = ServiceInfo(
        "_http._tcp.local.",
        "ESP32Server._http._tcp.local.",
        addresses=[socket.inet_aton(local_ip)],
        port=5000,
        properties={},
        server=f"{hostname}.local."
    )
    zeroconf = Zeroconf()
    zeroconf.register_service(service_info)
    return zeroconf, service_info

# Endpoint per ricevere i log dall'ESP32
@app.route('/receive_logs', methods=['POST'])
def receive_logs():
    global display_logs, server_logs
    log_data = request.data.decode('utf-8')
    timestamped_log = f"[{datetime.now().strftime('%H:%M:%S')}] {log_data}"
    display_logs.append(timestamped_log)
    server_logs.append(timestamped_log)
    return "Logs received", 200

# Endpoint per ottenere i log in formato JSON
@app.route('/get_logs', methods=['GET'])
def get_logs():
    global server_logs
    return jsonify(server_logs), 200

# Endpoint per visualizzare i log
@app.route('/get_display_logs', methods=['GET'])
def get_display_logs():
    global display_logs
    return jsonify(display_logs), 200

# Pagina per visualizzare i log
@app.route('/display_logs')
def display_logs_endpoint():
    template = """
    <html>
<head>
    <title>ESP32 Logs</title>
    <script>
async function updateLogs() {
    try {
        const response = await fetch('/get_display_logs');
        if (response.ok) {
            const logs = await response.json();
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '';
            logs.forEach(log => {
                const logElement = document.createElement('div');
                logElement.textContent = log;
                logContainer.prepend(logElement);
            });
        }
    } catch (error) {
        console.error('Errore nell aggiornamento dei log:', error);
    }
}
setInterval(updateLogs, 200);
</script>
</head>
<body>
    <h1>Logs ricevuti dall'ESP32</h1>
    <pre id="logContainer">Caricamento log...</pre>
</body>
</html>
    """
    return render_template_string(template)

# Endpoint per cancellare i log dal server
@app.route('/clear_server_logs', methods=['GET'])
def clear_logs():
    global server_logs
    server_logs = []
    return "Logs cancellati dal server", 200

# Endpoint per cancellare i log dalla visualizzazione
@app.route('/clear_display_logs', methods=['GET'])
def clear_display_logs():
    global display_logs
    display_logs = []
    return "Logs cancellati dalla visualizzazione", 200

# Endpoint per ricevere i dati numerici dall'ESP32
@app.route('/receive_data', methods=['POST'])
def receive_data_logs():
    global data_logs
    try:
        data = request.get_json()
        if isinstance(data, list):
            server_data.append(data)
            return "Data logs received", 200
        else:
            return "Invalid data format", 400
    except Exception as e:
        return f"Error processing data: {str(e)}", 500

# Endpoint per ottenere i dati numerici in formato JSON
@app.route('/get_data', methods=['GET'])
def get_data_logs():
    global server_data
    return jsonify(server_data), 200

# Endpoint per cancellare i dati numerici dal server
@app.route('/clear_server_data', methods=['GET'])
def clear_server_data():
    global server_data
    server_data = []
    return "Dati cancellati dal server.", 200

# Endpoint per verificare se il server è attivo
@app.route('/ping', methods=['GET'])
def ping():
    return jsonify({"status": "active"}), 200

@app.route('/favicon.ico')
def favicon():
    return '', 204

# Endpoint per arrestare il server
@app.route('/shutdown', methods=['POST'])
def shutdown():
    global shutdown_signal
    shutdown_signal = True
    return "Server arrestato", 200

# Funzione per avviare il server Flask
def run_server():
    app.run(host='0.0.0.0', port=5000)

if __name__ == '__main__':
    zeroconf, service_info = start_mdns_service()
    server_thread = threading.Thread(target=run_server)
    server_thread.start()

    try:
        while not shutdown_signal:
            pass
    finally:
        zeroconf.unregister_service(service_info)
        zeroconf.close()
        print("Server arrestato.")
        os.kill(os.getpid(), signal.SIGTERM)

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\server.py ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\server_launcher.py ---

import subprocess
import os
import requests

# Variabile per tenere traccia del processo del server Flask
server_process = None

# Funzione per avviare il server in un nuovo terminale
def start_server():
    global server_process
    if server_process is None:
        if os.name == 'nt':  # Windows
            command = ['start', 'cmd', '/k', 'python', 'server.py']
        else:  # MacOS/Linux
            command = ['gnome-terminal', '--', 'python3', 'server.py']
        server_process = subprocess.Popen(command, shell=(os.name == 'nt'))
        print("Server avviato in un nuovo terminale.")
    else:
        print("Il server è già in esecuzione.")

# Funzione per arrestare il server tramite l'endpoint /shutdown
def stop_server():
    global server_process
    try:
        response = requests.post('http://127.0.0.1:5000/shutdown')
        if response.status_code == 200:
            print("Server fermato.")
        else:
            print(f"Errore nell'arresto del server: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Errore di connessione al server: {e}")
    finally:
        if server_process:
            server_process.terminate()
            server_process = None

# Funzione per cancellare i log dal server
def clear_server_logs():
    try:
        response = requests.get('http://127.0.0.1:5000/clear_server_logs')
        if response.status_code == 200:
            print("Logs cancellati dal server.")
        else:
            print(f"Errore nella cancellazione dei log: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Errore di connessione al server: {e}")

# Funzione per cancellare i log dalla visualizzazione
def clear_display_logs():
    try:
        response = requests.get('http://127.0.0.1:5000/clear_display_logs')
        if response.status_code == 200:
            print("Logs cancellati dalla visualizzazione.")
        else:
            print(f"Errore nella cancellazione dei log: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Errore di connessione al server: {e}")
        
# Funzione per cancellare i dati dal server
def clear_server_data():
    try:
        response = requests.get('http://127.0.0.1:5000/clear_server_data')
        if response.status_code == 200:
            print("Dati cancellati dal server.")
        else:
            print(f"Errore nella cancellazione dei dati: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"Errore di connessione al server: {e}")

# Funzione per gestire i comandi
def handle_commands():
    while True:
        command = input("Comando: ").strip().lower()
        if command == "start":
            start_server()
        elif command == "stop":
            stop_server()
        elif command == "clear_server_logs":
            clear_server_logs()
        elif command == "clear_display_logs":
            clear_display_logs()
        elif command == "clear_server_data":
            clear_server_data()
        elif command == "status":
            if server_process and server_process.poll() is None:
                print("Il server è attivo.")
            else:
                print("Il server non è attivo.")
        elif command == "quit":
            stop_server()
            print("Chiusura del launcher...")
            break
        else:
            print(f"Comando sconosciuto: {command}")

if __name__ == "__main__":
    print("Comandi disponibili: start, stop, clear_server_logs, clear_display_logs, clear_server_data, status, quit")
    handle_commands()

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\server_launcher.py ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32PWM.cpp ---

/*
 * ESP32PWM.cpp
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#include <ESP32PWM.h>
#include "esp32-hal-ledc.h"

// initialize the class variable ServoCount
int ESP32PWM::PWMCount = -1;              // the total number of attached servos
bool  ESP32PWM::explicateAllocationMode=false;
ESP32PWM * ESP32PWM::ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
long ESP32PWM::timerFreqSet[4] = { -1, -1, -1, -1 };
int ESP32PWM::timerCount[4] = { 0, 0, 0, 0 };

static const char* TAG = "ESP32PWM";

// The ChannelUsed array elements are 0 if never used, 1 if in use, and -1 if used and disposed
// (i.e., available for reuse)
/**
 * allocateTimer
 * @param a timer number 0-3 indicating which timer to allocate in this library
 * Switch to explicate allocation mode
 *
 */
void ESP32PWM::allocateTimer(int timerNumber){
	if(timerNumber<0 || timerNumber>3)
		return;
	if(ESP32PWM::explicateAllocationMode==false){
		ESP32PWM::explicateAllocationMode=true;
		for(int i=0;i<4;i++)
			ESP32PWM::timerCount[i]=4;// deallocate all timers to start mode
	}
	ESP32PWM::timerCount[timerNumber]=0;
}

ESP32PWM::ESP32PWM() {
	resolutionBits = 8;
	pwmChannel = -1;
	pin = -1;
	myFreq = -1;
	if (PWMCount == -1) {
		for (int i = 0; i < NUM_PWM; i++)
			ChannelUsed[i] = NULL; // load invalid data into the storage array of pin mapping
		PWMCount = PWM_BASE_INDEX; // 0th channel does not work with the PWM system
	}
}

ESP32PWM::~ESP32PWM() {
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
#else
		ledcDetachPin(pin);
#endif
#else
		ledcDetachPin(pin);
#endif
	}
	deallocate();
}

double ESP32PWM::_ledcSetupTimerFreq(uint8_t pin, double freq,
		uint8_t bit_num) {

#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(pin, freq, bit_num);
#else
	return ledcSetup(pin, freq, bit_num);
#endif
#else
	return ledcSetup(pin, freq, bit_num);
#endif

}

int ESP32PWM::timerAndIndexToChannel(int timerNum, int index) {
	int localIndex = 0;
	for (int j = 0; j < NUM_PWM; j++) {
		if (((j / 2) % 4) == timerNum) {
			if (localIndex == index) {
				return j;
			}
			localIndex++;
		}
	}
	return -1;
}
int ESP32PWM::allocatenext(double freq) {
	long freqlocal = (long) freq;
	if (pwmChannel < 0) {
		for (int i = 0; i < 4; i++) {
			bool freqAllocated = ((timerFreqSet[i] == freqlocal)
					|| (timerFreqSet[i] == -1));
			if (freqAllocated && timerCount[i] < 4) {
				if (timerFreqSet[i] == -1) {
					//Serial.println("Starting timer "+String(i)+" at freq "+String(freq));
					timerFreqSet[i] = freqlocal;
				}
				//Serial.println("Free channel timer "+String(i)+" at freq "+String(freq)+" remaining "+String(4-timerCount[i]));

				timerNum = i;
				for (int index=0; index<4; ++index)
				{
					int myTimerNumber = timerAndIndexToChannel(timerNum,index);
					if ((myTimerNumber >= 0)  && (!ChannelUsed[myTimerNumber]))
					{
						pwmChannel = myTimerNumber;
// 						Serial.println(
// 							"PWM on ledc channel #" + String(pwmChannel)
// 									+ " using 'timer " + String(timerNum)
// 									+ "' to freq " + String(freq) + "Hz");
						ChannelUsed[pwmChannel] = this;
						timerCount[timerNum]++;
						PWMCount++;
						myFreq = freq;
						return pwmChannel;
					}
				}
			} else {
//				if(timerFreqSet[i]>0)
//					Serial.println("Timer freq mismatch target="+String(freq)+" on timer "+String(i)+" was "+String(timerFreqSet[i]));
//				else
//					Serial.println("Timer out of channels target="+String(freq)+" on timer "+String(i)+" was "+String(timerCount[i]));
			}
		}
	} else {
		return pwmChannel;
	}
	ESP_LOGE(TAG, 
			"ERROR All PWM timers allocated! Can't accomodate %d Hz\r\nHalting...", freq);
	while (1)
		;
}
void ESP32PWM::deallocate() {
	if (pwmChannel < 0)
		return;
	ESP_LOGE(TAG, "PWM deallocating LEDc #%d",pwmChannel);
	timerCount[getTimer()]--;
	if (timerCount[getTimer()] == 0) {
		timerFreqSet[getTimer()] = -1; // last pwn closed out
	}
	timerNum = -1;
	attachedState = false;
	ChannelUsed[pwmChannel] = NULL;
	pwmChannel = -1;
	PWMCount--;

}

int ESP32PWM::getChannel() {
	if (pwmChannel < 0) {
		ESP_LOGE(TAG, "FAIL! must setup() before using get channel!");
	}
	return pwmChannel;
}

double ESP32PWM::setup(double freq, uint8_t resolution_bits) {
	checkFrequencyForSideEffects(freq);

	resolutionBits = resolution_bits;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		double val = ledcAttach(getPin(), freq, resolution_bits);
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif

		attachPin(pin);
		return val;
	}
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(getPin(), freq, resolution_bits);
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
}
double ESP32PWM::getDutyScaled() {
	return mapf((double) myDuty, 0, (double) ((1 << resolutionBits) - 1), 0.0,
			1.0);
}
void ESP32PWM::writeScaled(double duty) {
	write(mapf(duty, 0.0, 1.0, 0, (double) ((1 << resolutionBits) - 1)));
}
void ESP32PWM::write(uint32_t duty) {
	myDuty = duty;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	ledcWrite(getPin(), duty);
#else
	ledcWrite(getChannel(), duty);
#endif
#else
	ledcWrite(getChannel(), duty);
#endif
}
void ESP32PWM::adjustFrequencyLocal(double freq, double dutyScaled) {
	timerFreqSet[getTimer()] = (long) freq;
	myFreq = freq;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttach(getPin(), freq, resolutionBits); // re-attach the pin after frequency adjust
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif

	} else {
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
	}
}
void ESP32PWM::adjustFrequency(double freq, double dutyScaled) {
	if(dutyScaled<0)
		dutyScaled=getDutyScaled();
	writeScaled(dutyScaled);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
		}
	}
}
double ESP32PWM::writeTone(double freq) {
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
			write(1 << (resolutionBits-1)); // writeScaled(0.5);
		}
	}

	return 0;
}
double ESP32PWM::writeNote(note_t note, uint8_t octave) {
	const uint16_t noteFrequencyBase[12] = {
			//   C        C#       D        Eb       E        F       F#        G       G#        A       Bb        B
			4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459,
			7902 };

	if (octave > 8 || note >= NOTE_MAX) {
		return 0;
	}
	double noteFreq = (double) noteFrequencyBase[note]
			/ (double) (1 << (8 - octave));
	return writeTone(noteFreq);
}
uint32_t ESP32PWM::read() {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcRead(getPin());
#else
	return ledcRead(getChannel());
#endif
#else
	return ledcRead(getChannel());
#endif

}
double ESP32PWM::readFreq() {
	return myFreq;
}
void ESP32PWM::attach(int p) {
	pin = p;
	attachedState = true;
}
void ESP32PWM::attachPin(uint8_t pin) {

	if (hasPwm(pin)) {
		attach(pin);
		bool success=true;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		success=ledcAttach(pin, readFreq(), resolutionBits);
#else
		ledcAttachPin(pin, getChannel());
#endif
#else
		ledcAttachPin(pin, getChannel());
#endif
		if(success)
			return;
		ESP_LOGE(TAG, "ERROR PWM channel failed to configure on!",pin);
		return;
	}
		
#if defined(CONFIG_IDF_TARGET_ESP32S2)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,26,33-42",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,35-45,47-48",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-10,18-21",pin);
#else
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif

}
void ESP32PWM::attachPin(uint8_t pin, double freq, uint8_t resolution_bits) {

	if (hasPwm(pin)){
		int ret=setup(freq, resolution_bits);
		ESP_LOGW(TAG, "Pin Setup %d with code %d",pin,ret);
	}
	else
		ESP_LOGE(TAG, "ERROR Pin Failed %d ",pin);
	attachPin(pin);
}
void ESP32PWM::detachPin(int pin) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)

	ledcDetach(pin);
#else
	ledcDetachPin(pin);
#endif
#else
	ledcDetachPin(pin);
#endif
	deallocate();
}
/* Side effects of frequency changes happen because of shared timers
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

bool ESP32PWM::checkFrequencyForSideEffects(double freq) {

	allocatenext(freq);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);

		if (pwm == pwmChannel)
			continue;
		if (ChannelUsed[pwm] != NULL)
			if (ChannelUsed[pwm]->getTimer() == getTimer()) {
				double diff = abs(ChannelUsed[pwm]->myFreq - freq);
				if (abs(diff) > 0.1) {
					ESP_LOGW(TAG, 
							"\tWARNING PWM channel %d	\
							 shares a timer with channel %d\n	\
							\tchanging the frequency to %d		\
							Hz will ALSO change channel %d	\
							\n\tfrom its previous frequency of %d Hz\n "
								,pwmChannel, pwm, freq,pwm, ChannelUsed[pwm]->myFreq);
					ChannelUsed[pwm]->myFreq = freq;
				}
			}
	}
	return true;
}

ESP32PWM* pwmFactory(int pin) {
	for (int i = 0; i < NUM_PWM; i++)
		if (ESP32PWM::ChannelUsed[i] != NULL) {
			if (ESP32PWM::ChannelUsed[i]->getPin() == pin)
				return ESP32PWM::ChannelUsed[i];
		}
	return NULL;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32PWM.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32PWM.h ---

/*
 * ESP32PWM.h
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#ifndef LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#define LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#include "esp32-hal-ledc.h"
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

#if defined(CONFIG_IDF_TARGET_ESP32C3)
#define NUM_PWM 6
#elif defined(CONFIG_IDF_TARGET_ESP32S2)   ||  defined(CONFIG_IDF_TARGET_ESP32S3)
#define NUM_PWM 8
#else 
#define NUM_PWM 16
#endif

#define PWM_BASE_INDEX 0
#define USABLE_ESP32_PWM (NUM_PWM-PWM_BASE_INDEX)
#include <cstdint>

class ESP32PWM {
private:

	void attach(int pin);
	int pwmChannel = 0;                         // channel number for this servo
	bool attachedState = false;
	int pin;
	uint8_t resolutionBits;
	double myFreq;
	int allocatenext(double freq);

	static double _ledcSetupTimerFreq(uint8_t pin, double freq,
			uint8_t bit_num);

	bool checkFrequencyForSideEffects(double freq);

	void adjustFrequencyLocal(double freq, double dutyScaled);
	static double mapf(double x, double in_min, double in_max, double out_min,
			double out_max) {
		if(x>in_max)
			return out_max;
		if(x<in_min)
			return out_min;
		return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	}

	double setup(double freq, uint8_t resolution_bits=10);
	//channel 0-15 resolution 1-16bits freq limits depend on resolution9
	void attachPin(uint8_t pin);
	// pin allocation
	void deallocate();
public:
	// setup
	ESP32PWM();
	virtual ~ESP32PWM();


	void detachPin(int pin);
	void attachPin(uint8_t pin, double freq, uint8_t resolution_bits=10);
	bool attached() {
		return attachedState;
	}

	// write raw duty cycle
	void write(uint32_t duty);
	// Write a duty cycle to the PWM using a unit vector from 0.0-1.0
	void writeScaled(double duty);
	//Adjust frequency
	double writeTone(double freq);
	double writeNote(note_t note, uint8_t octave);
	void adjustFrequency(double freq, double dutyScaled=-1);

	// Read pwm data
	uint32_t read();
	double readFreq();
	double getDutyScaled();

	//Timer data
	static int timerAndIndexToChannel(int timer, int index);
	/**
	 * allocateTimer
	 * @param a timer number 0-3 indicating which timer to allocate in this library
	 * Switch to explicate allocation mode
	 *
	 */
	static void allocateTimer(int timerNumber);
	static bool explicateAllocationMode;
	int getTimer() {
		return timerNum;
	}
	int timerNum = -1;
	uint32_t myDuty = 0;
	int getChannel();
	static int PWMCount;              // the total number of attached pwm
	static int timerCount[4];
	static ESP32PWM * ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
	static long timerFreqSet[4];

	// Helper functions
	int getPin() {
		return pin;
	}
	static bool hasPwm(int pin) {
#if defined(CONFIG_IDF_TARGET_ESP32S2)
		if ((pin >=1 && pin <= 21) || //21
				(pin == 26) || //1
				(pin >= 33 && pin <= 42)) //10
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
		if ((pin >=1 && pin <= 21) || //20
				(pin >= 35 && pin <= 45) || //11
				(pin == 47) || (pin == 48)) //2
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
		if ((pin >=0 && pin <= 10) || //11
				(pin >= 18 && pin <= 21)) //4
#elif defined(CONFIG_IDF_TARGET_ESP32C6)
		if ((pin >=0 && pin <= 9) || //10
				(pin >= 12 && pin <= 23)) //12
#elif defined(CONFIG_IDF_TARGET_ESP32H2)
		if ((pin >=0 && pin <= 5) || //6
				(pin >= 8 && pin <= 14) || //7
				(pin >= 22 && pin <= 27)) //6
#else
		if ((pin == 2) || //1
				(pin == 4) || //1
				(pin == 5) || //1
				((pin >= 12) && (pin <= 19)) || //8
				((pin >= 21) && (pin <= 23)) || //3
				((pin >= 25) && (pin <= 27)) || //3
				(pin == 32) || (pin == 33)) //2
#endif
			return true;
		return false;
	}
	static int channelsRemaining() {
		return NUM_PWM - PWMCount;
	}
	static boolean DISABLE_DAC;


};

ESP32PWM* pwmFactory(int pin);

#endif /* LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_ */

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32PWM.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32Servo.cpp ---

/*
Copyright (c) 2017 John K. Bennett. All right reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

* Notes on the implementation:
* The ESP32 supports 16 hardware LED PWM channels that are intended
* to be used for LED brightness control. The low level ESP32 code
* (esp32-hal-ledc.*) allows us to set the PWM frequency and bit-depth,
* and then manipulate them by setting bits in the relevant control
* registers.
*
* Different servos require different pulse widths to vary servo angle, but the range is
* an approximately 500-2500 microsecond pulse every 20ms (50Hz). In general, hobbyist servos
* sweep 180 degrees, so the lowest number in the published range for a particular servo
* represents an angle of 0 degrees, the middle of the range represents 90 degrees, and the top
* of the range represents 180 degrees. So for example, if the range is 1000us to 2000us,
* 1000us would equal an angle of 0, 1500us would equal 90 degrees, and 2000us would equal 180
* degrees. We vary pulse width (recall that the pulse period is already set to 20ms) as follows:
*
* The ESP32 PWM timers allow us to set the timer width (max 20 bits). Thus
* the timer "tick" length is (pulse_period/2**timer_width), and the equation for pulse_high_width
* (the portion of the 20ms cycle that the signal is high) becomes:
*
*                  pulse_high_width  = count * tick_length
*                                    = count * (pulse_period/2**timer_width)
*
*            and   count = (pulse_high_width / (pulse_period/2**timer_width))
*
* So, for example, if I want a 1500us pulse_high_width, I set pulse_period to 20ms (20000us)
* (this value is set in the ledcSetup call), and count (used in the ledcWrite call) to
* 1500/(20000/65536), or 4924. This is the value we write to the timer in the ledcWrite call.
* If we increase the timer_width, the timer_count values need to be adjusted.
*
* The servo signal pins connect to any available GPIO pins on the ESP32, but not all pins are
* GPIO pins.
*
* The ESP32 is a 32 bit processor that includes FP support; this code reflects that fact.
*/

#include <ESP32Servo.h>
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

static const char* TAG = "ESP32Servo";

Servo::Servo()
{		// initialize this channel with plausible values, except pin # (we set pin # when attached)
	REFRESH_CPS = 50;
	this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
	this->timer_width = DEFAULT_TIMER_WIDTH;
	this->pinNumber = -1;     // make it clear that we haven't attached a pin to this channel
	this->min = DEFAULT_uS_LOW;
	this->max = DEFAULT_uS_HIGH;
	this->timer_width_ticks = pow(2,this->timer_width);

}
ESP32PWM * Servo::getPwm(){

	return &pwm;
}

int Servo::attach(int pin)
{

    return (this->attach(pin, DEFAULT_uS_LOW, DEFAULT_uS_HIGH));
}

int Servo::attach(int pin, int min, int max)
{
    ESP_LOGW(TAG, "Attempting to Attach servo on pin=%d min=%d max=%d",pin,min,max);

#ifdef ENFORCE_PINS
        // ESP32 Recommend only the following pins 2,4,12-19,21-23,25-27,32-33
		// ESP32-S2 only the following pins 1-21,26,33-42
        if (pwm.hasPwm(pin))
        {
#endif

            // OK to proceed; first check for new/reuse
            if (this->pinNumber < 0) // we are attaching to a new or previously detached pin; we need to initialize/reinitialize
            {
                this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
                this->timer_width = DEFAULT_TIMER_WIDTH;
                this->timer_width_ticks = pow(2,this->timer_width);
            }
            this->pinNumber = pin;
#ifdef ENFORCE_PINS
        }
        else
        {
#ifdef __XTENSA_esp32s3__
if(
#endif

#if defined(CONFIG_IDF_TARGET_ESP32S2)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,26,33-42", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
			    ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,35-45,47-48", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-10,18-21", pin);
#else
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif
            return 0;
        }
#endif


        // min/max checks 
        if (min < MIN_PULSE_WIDTH)          // ensure pulse width is valid
            min = MIN_PULSE_WIDTH;
        if (max > MAX_PULSE_WIDTH)
            max = MAX_PULSE_WIDTH;
        this->min = min;     //store this value in uS
        this->max = max;    //store this value in uS
        // Set up this channel
        // if you want anything other than default timer width, you must call setTimerWidth() before attach

        pwm.attachPin(this->pinNumber,REFRESH_CPS, this->timer_width );   // GPIO pin assigned to channel
        ESP_LOGW(TAG, "Success to Attach servo : %d on PWM %d",pin,pwm.getChannel());

        return pwm.getChannel();
}

void Servo::detach()
{
    if (this->attached())
    {
        //keep track of detached servos channels so we can reuse them if needed
        pwm.detachPin(this->pinNumber);

        this->pinNumber = -1;
    }
}

void Servo::write(int value)
{
    // treat values less than MIN_PULSE_WIDTH (500) as angles in degrees (valid values in microseconds are handled as microseconds)
    if (value < MIN_PULSE_WIDTH)
    {
        if (value < 0)
            value = 0;
        else if (value > 180)
            value = 180;

        value = map(value, 0, 180, this->min, this->max);
    }
    this->writeMicroseconds(value);
}

void Servo::writeMicroseconds(int value)
{
    writeTicks(usToTicks(value));  // convert to ticks
}

void Servo::writeTicks(int value)
{
    // calculate and store the values for the given channel
    if (this->attached())   // ensure channel is valid
    {
        if (value < usToTicks(this->min))      // ensure ticks are in range
            value = usToTicks(this->min);
        else if (value > usToTicks(this->max))
            value = usToTicks(this->max);
        this->ticks = value;
        // do the actual write
        pwm.write( this->ticks);
    }
}

void Servo::release()
{
    if (this->attached())   // ensure channel is valid
        pwm.write(0);
}

int Servo::read() // return the value as degrees
{
    return (map(readMicroseconds(), this->min, this->max, 0, 180));
}

int Servo::readMicroseconds()
{
    int pulsewidthUsec;
    if (this->attached())
    { 
        pulsewidthUsec = ticksToUs(this->ticks);
    }
    else
    {
        pulsewidthUsec = 0;
    }

    return (pulsewidthUsec);
}

int Servo::readTicks()
{
    return this->ticks;
}

bool Servo::attached()
{
    return (pwm.attached());
}

void Servo::setTimerWidth(int value)
{
    // only allow values between 10 and 14 for ESP32-C3
    // only allow values between 16 and 20 for other ESP32
    if (value < MINIMUM_TIMER_WIDTH )
        value = MINIMUM_TIMER_WIDTH;
    else if (value > MAXIMUM_TIMER_WIDTH)
        value = MAXIMUM_TIMER_WIDTH;
        
    // Fix the current ticks value after timer width change
    // The user can reset the tick value with a write() or writeUs()
    int widthDifference = this->timer_width - value;
    // if positive multiply by diff; if neg, divide
    if (widthDifference > 0)
    {
        this->ticks = widthDifference * this->ticks;
    }
    else if (widthDifference < 0)
    {
        this->ticks = this->ticks/-widthDifference;
    }
    
    this->timer_width = value;
    this->timer_width_ticks = pow(2,this->timer_width);
    
    // If this is an attached servo, clean up
    if (this->attached())
    {
        // detach, setup and attach again to reflect new timer width
    	pwm.detachPin(this->pinNumber);
    	pwm.attachPin(this->pinNumber, REFRESH_CPS, this->timer_width);
    }        
}

int Servo::readTimerWidth()
{
    return (this->timer_width);
}

int Servo::usToTicks(int usec)
{
    return (int)((double)usec / ((double)REFRESH_USEC / (double)this->timer_width_ticks)*(((double)REFRESH_CPS)/50.0));
}

int Servo::ticksToUs(int ticks)
{
    return (int)((double)ticks * ((double)REFRESH_USEC / (double)this->timer_width_ticks)/(((double)REFRESH_CPS)/50.0));
}

 

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32Servo.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32Servo.h ---

/*
 Copyright (c) 2017 John K. Bennett. All right reserved.

 ESP32_Servo.h - Servo library for ESP32 - Version 1

 Original Servo.h written by Michael Margolis in 2009

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/* 
 A servo is activated by creating an instance of the Servo class, and passing
 the desired GPIO pin to the attach() method.
 The servos are pulsed in the background using the value most recently
 written using the write() method.

 The class methods are:

 Servo - Class for manipulating servo motors connected to ESP32 pins.
 int attach(pin )  - Attaches the given GPIO pin to the next free channel
 (channels that have previously been detached are used first),
 returns channel number or 0 if failure. All pin numbers are allowed,
 but only pins 2,4,12-19,21-23,25-27,32-33 are recommended.
 int attach(pin, min, max  ) - Attaches to a pin setting min and max
 values in microseconds; enforced minimum min is 500, enforced max
 is 2500. Other semantics same as attach().
 void write () - Sets the servo angle in degrees; a value below 500 is
 treated as a value in degrees (0 to 180). These limit are enforced,
 i.e., values are treated as follows:
 Value                                   Becomes
 -----                                   -------
 < 0                                        0
 0 - 180                             value (treated as degrees)
 181 - 499                                 180
 500 - (min-1)                             min
 min-max (from attach or default)    value (treated as microseconds)
 (max+1) - 2500                            max

 void writeMicroseconds() - Sets the servo pulse width in microseconds.
 min and max are enforced (see above).
 int read() - Gets the last written servo pulse width as an angle between 0 and 180.
 int readMicroseconds()   - Gets the last written servo pulse width in microseconds.
 bool attached() - Returns true if this servo instance is attached.
 void detach() - Stops an the attached servo, frees its attached pin, and frees
 its channel for reuse).

 *** ESP32-specific functions **
 setTimerWidth(value) - Sets the PWM timer width (must be 16-20) (ESP32 ONLY);
 as a side effect, the pulse width is recomputed.
 int readTimerWidth() - Gets the PWM timer width (ESP32 ONLY)
 */

#ifndef ESP32_Servo_h
#define ESP32_Servo_h
//#include "analogWrite.h"
#include "ESP32PWM.h"
//#include "ESP32Tone.h"
//Enforce only using PWM pins on the ESP32
#define ENFORCE_PINS
// Default Arduino Servo.h
#define DEFAULT_uS_LOW 544
#define DEFAULT_uS_HIGH 2400

// Values for TowerPro MG995 large servos (and many other hobbyist servos)
//#define DEFAULT_uS_LOW 1000        // 1000us
//#define DEFAULT_uS_HIGH 2000      // 2000us

// Values for TowerPro SG90 small servos
//#define DEFAULT_uS_LOW 400
//#define DEFAULT_uS_HIGH 2400

#ifdef ARDUINO_ESP32C3_DEV
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 14
#define DEFAULT_TIMER_WIDTH 10
#else
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 20
#define DEFAULT_TIMER_WIDTH 10
#endif
#define DEFAULT_TIMER_WIDTH_TICKS 1024

#define ESP32_Servo_VERSION           1     // software version of this library

#define MIN_PULSE_WIDTH       500     // the shortest pulse sent to a servo  
#define MAX_PULSE_WIDTH      2500     // the longest pulse sent to a servo 
#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
#define DEFAULT_PULSE_WIDTH_TICKS 4825
//#define REFRESH_CPS            50
#define REFRESH_USEC         20000

#define MAX_SERVOS              16     // no. of PWM channels in ESP32

/*
 * This group/channel/timmer mapping is for information only;
 * the details are handled by lower-level code
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

class Servo {

public:
	Servo();
	// Arduino Servo Library calls
	int attach(int pin); // attach the given pin to the next free channel, returns channel number or 0 if failure
	int attach(int pin, int min, int max); // as above but also sets min and max values for writes.
	void detach();
	void write(int value); // if value is < MIN_PULSE_WIDTH its treated as an angle, otherwise as pulse width in microseconds
	void writeMicroseconds(int value);     // Write pulse width in microseconds
	void writeTicks(int value);     // Write ticks, the smallest increment the servo can handle
	void release();
	int read(); // returns current pulse width as an angle between 0 and 180 degrees
	int readMicroseconds(); // returns current pulse width in microseconds for this servo
	int readTicks(); // returns current ticks, the smallest increment the servo can handle
	bool attached(); // return true if this servo is attached, otherwise false

	// ESP32 only functions
	void setTimerWidth(int value);     // set the PWM timer width (ESP32 ONLY)
	int readTimerWidth();              // get the PWM timer width (ESP32 ONLY)
	void setPeriodHertz(int hertz){
		REFRESH_CPS=hertz;
		setTimerWidth(this->timer_width);
	}
private:
	int usToTicks(int usec);
	int ticksToUs(int ticks);
//   static int ServoCount;                             // the total number of attached servos
//   static int ChannelUsed[];                          // used to track whether a channel is in service
//   int servoChannel = 0;                              // channel number for this servo

	int min = DEFAULT_uS_LOW;           // minimum pulse width for this servo
	int max = DEFAULT_uS_HIGH;            // maximum pulse width for this servo
	int pinNumber = 0;                      // GPIO pin assigned to this channel
	int timer_width = DEFAULT_TIMER_WIDTH; // ESP32 allows variable width PWM timers
	int ticks = DEFAULT_PULSE_WIDTH_TICKS; // current pulse width on this channel
	int timer_width_ticks = DEFAULT_TIMER_WIDTH_TICKS; // no. of ticks at rollover; varies with width
	ESP32PWM * getPwm(); // get the PWM object
	ESP32PWM pwm;
	int REFRESH_CPS = 50;

};
#endif

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32-s3-devkitc-1\ESP32Servo\src\ESP32Servo.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32PWM.cpp ---

/*
 * ESP32PWM.cpp
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#include <ESP32PWM.h>
#include "esp32-hal-ledc.h"

// initialize the class variable ServoCount
int ESP32PWM::PWMCount = -1;              // the total number of attached servos
bool  ESP32PWM::explicateAllocationMode=false;
ESP32PWM * ESP32PWM::ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
long ESP32PWM::timerFreqSet[4] = { -1, -1, -1, -1 };
int ESP32PWM::timerCount[4] = { 0, 0, 0, 0 };

static const char* TAG = "ESP32PWM";

// The ChannelUsed array elements are 0 if never used, 1 if in use, and -1 if used and disposed
// (i.e., available for reuse)
/**
 * allocateTimer
 * @param a timer number 0-3 indicating which timer to allocate in this library
 * Switch to explicate allocation mode
 *
 */
void ESP32PWM::allocateTimer(int timerNumber){
	if(timerNumber<0 || timerNumber>3)
		return;
	if(ESP32PWM::explicateAllocationMode==false){
		ESP32PWM::explicateAllocationMode=true;
		for(int i=0;i<4;i++)
			ESP32PWM::timerCount[i]=4;// deallocate all timers to start mode
	}
	ESP32PWM::timerCount[timerNumber]=0;
}

ESP32PWM::ESP32PWM() {
	resolutionBits = 8;
	pwmChannel = -1;
	pin = -1;
	myFreq = -1;
	if (PWMCount == -1) {
		for (int i = 0; i < NUM_PWM; i++)
			ChannelUsed[i] = NULL; // load invalid data into the storage array of pin mapping
		PWMCount = PWM_BASE_INDEX; // 0th channel does not work with the PWM system
	}
}

ESP32PWM::~ESP32PWM() {
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
#else
		ledcDetachPin(pin);
#endif
#else
		ledcDetachPin(pin);
#endif
	}
	deallocate();
}

double ESP32PWM::_ledcSetupTimerFreq(uint8_t pin, double freq,
		uint8_t bit_num) {

#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(pin, freq, bit_num);
#else
	return ledcSetup(pin, freq, bit_num);
#endif
#else
	return ledcSetup(pin, freq, bit_num);
#endif

}

int ESP32PWM::timerAndIndexToChannel(int timerNum, int index) {
	int localIndex = 0;
	for (int j = 0; j < NUM_PWM; j++) {
		if (((j / 2) % 4) == timerNum) {
			if (localIndex == index) {
				return j;
			}
			localIndex++;
		}
	}
	return -1;
}
int ESP32PWM::allocatenext(double freq) {
	long freqlocal = (long) freq;
	if (pwmChannel < 0) {
		for (int i = 0; i < 4; i++) {
			bool freqAllocated = ((timerFreqSet[i] == freqlocal)
					|| (timerFreqSet[i] == -1));
			if (freqAllocated && timerCount[i] < 4) {
				if (timerFreqSet[i] == -1) {
					//Serial.println("Starting timer "+String(i)+" at freq "+String(freq));
					timerFreqSet[i] = freqlocal;
				}
				//Serial.println("Free channel timer "+String(i)+" at freq "+String(freq)+" remaining "+String(4-timerCount[i]));

				timerNum = i;
				for (int index=0; index<4; ++index)
				{
					int myTimerNumber = timerAndIndexToChannel(timerNum,index);
					if ((myTimerNumber >= 0)  && (!ChannelUsed[myTimerNumber]))
					{
						pwmChannel = myTimerNumber;
// 						Serial.println(
// 							"PWM on ledc channel #" + String(pwmChannel)
// 									+ " using 'timer " + String(timerNum)
// 									+ "' to freq " + String(freq) + "Hz");
						ChannelUsed[pwmChannel] = this;
						timerCount[timerNum]++;
						PWMCount++;
						myFreq = freq;
						return pwmChannel;
					}
				}
			} else {
//				if(timerFreqSet[i]>0)
//					Serial.println("Timer freq mismatch target="+String(freq)+" on timer "+String(i)+" was "+String(timerFreqSet[i]));
//				else
//					Serial.println("Timer out of channels target="+String(freq)+" on timer "+String(i)+" was "+String(timerCount[i]));
			}
		}
	} else {
		return pwmChannel;
	}
	ESP_LOGE(TAG, 
			"ERROR All PWM timers allocated! Can't accomodate %d Hz\r\nHalting...", freq);
	while (1)
		;
}
void ESP32PWM::deallocate() {
	if (pwmChannel < 0)
		return;
	ESP_LOGE(TAG, "PWM deallocating LEDc #%d",pwmChannel);
	timerCount[getTimer()]--;
	if (timerCount[getTimer()] == 0) {
		timerFreqSet[getTimer()] = -1; // last pwn closed out
	}
	timerNum = -1;
	attachedState = false;
	ChannelUsed[pwmChannel] = NULL;
	pwmChannel = -1;
	PWMCount--;

}

int ESP32PWM::getChannel() {
	if (pwmChannel < 0) {
		ESP_LOGE(TAG, "FAIL! must setup() before using get channel!");
	}
	return pwmChannel;
}

double ESP32PWM::setup(double freq, uint8_t resolution_bits) {
	checkFrequencyForSideEffects(freq);

	resolutionBits = resolution_bits;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		double val = ledcAttach(getPin(), freq, resolution_bits);
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif

		attachPin(pin);
		return val;
	}
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(getPin(), freq, resolution_bits);
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
}
double ESP32PWM::getDutyScaled() {
	return mapf((double) myDuty, 0, (double) ((1 << resolutionBits) - 1), 0.0,
			1.0);
}
void ESP32PWM::writeScaled(double duty) {
	write(mapf(duty, 0.0, 1.0, 0, (double) ((1 << resolutionBits) - 1)));
}
void ESP32PWM::write(uint32_t duty) {
	myDuty = duty;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	ledcWrite(getPin(), duty);
#else
	ledcWrite(getChannel(), duty);
#endif
#else
	ledcWrite(getChannel(), duty);
#endif
}
void ESP32PWM::adjustFrequencyLocal(double freq, double dutyScaled) {
	timerFreqSet[getTimer()] = (long) freq;
	myFreq = freq;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttach(getPin(), freq, resolutionBits); // re-attach the pin after frequency adjust
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif

	} else {
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
	}
}
void ESP32PWM::adjustFrequency(double freq, double dutyScaled) {
	if(dutyScaled<0)
		dutyScaled=getDutyScaled();
	writeScaled(dutyScaled);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
		}
	}
}
double ESP32PWM::writeTone(double freq) {
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
			write(1 << (resolutionBits-1)); // writeScaled(0.5);
		}
	}

	return 0;
}
double ESP32PWM::writeNote(note_t note, uint8_t octave) {
	const uint16_t noteFrequencyBase[12] = {
			//   C        C#       D        Eb       E        F       F#        G       G#        A       Bb        B
			4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459,
			7902 };

	if (octave > 8 || note >= NOTE_MAX) {
		return 0;
	}
	double noteFreq = (double) noteFrequencyBase[note]
			/ (double) (1 << (8 - octave));
	return writeTone(noteFreq);
}
uint32_t ESP32PWM::read() {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcRead(getPin());
#else
	return ledcRead(getChannel());
#endif
#else
	return ledcRead(getChannel());
#endif

}
double ESP32PWM::readFreq() {
	return myFreq;
}
void ESP32PWM::attach(int p) {
	pin = p;
	attachedState = true;
}
void ESP32PWM::attachPin(uint8_t pin) {

	if (hasPwm(pin)) {
		attach(pin);
		bool success=true;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		success=ledcAttach(pin, readFreq(), resolutionBits);
#else
		ledcAttachPin(pin, getChannel());
#endif
#else
		ledcAttachPin(pin, getChannel());
#endif
		if(success)
			return;
		ESP_LOGE(TAG, "ERROR PWM channel failed to configure on!",pin);
		return;
	}
		
#if defined(CONFIG_IDF_TARGET_ESP32S2)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,26,33-42",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,35-45,47-48",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-10,18-21",pin);
#else
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif

}
void ESP32PWM::attachPin(uint8_t pin, double freq, uint8_t resolution_bits) {

	if (hasPwm(pin)){
		int ret=setup(freq, resolution_bits);
		ESP_LOGW(TAG, "Pin Setup %d with code %d",pin,ret);
	}
	else
		ESP_LOGE(TAG, "ERROR Pin Failed %d ",pin);
	attachPin(pin);
}
void ESP32PWM::detachPin(int pin) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)

	ledcDetach(pin);
#else
	ledcDetachPin(pin);
#endif
#else
	ledcDetachPin(pin);
#endif
	deallocate();
}
/* Side effects of frequency changes happen because of shared timers
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

bool ESP32PWM::checkFrequencyForSideEffects(double freq) {

	allocatenext(freq);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);

		if (pwm == pwmChannel)
			continue;
		if (ChannelUsed[pwm] != NULL)
			if (ChannelUsed[pwm]->getTimer() == getTimer()) {
				double diff = abs(ChannelUsed[pwm]->myFreq - freq);
				if (abs(diff) > 0.1) {
					ESP_LOGW(TAG, 
							"\tWARNING PWM channel %d	\
							 shares a timer with channel %d\n	\
							\tchanging the frequency to %d		\
							Hz will ALSO change channel %d	\
							\n\tfrom its previous frequency of %d Hz\n "
								,pwmChannel, pwm, freq,pwm, ChannelUsed[pwm]->myFreq);
					ChannelUsed[pwm]->myFreq = freq;
				}
			}
	}
	return true;
}

ESP32PWM* pwmFactory(int pin) {
	for (int i = 0; i < NUM_PWM; i++)
		if (ESP32PWM::ChannelUsed[i] != NULL) {
			if (ESP32PWM::ChannelUsed[i]->getPin() == pin)
				return ESP32PWM::ChannelUsed[i];
		}
	return NULL;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32PWM.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32PWM.h ---

/*
 * ESP32PWM.h
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#ifndef LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#define LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#include "esp32-hal-ledc.h"
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

#if defined(CONFIG_IDF_TARGET_ESP32C3)
#define NUM_PWM 6
#elif defined(CONFIG_IDF_TARGET_ESP32S2)   ||  defined(CONFIG_IDF_TARGET_ESP32S3)
#define NUM_PWM 8
#else 
#define NUM_PWM 16
#endif

#define PWM_BASE_INDEX 0
#define USABLE_ESP32_PWM (NUM_PWM-PWM_BASE_INDEX)
#include <cstdint>

class ESP32PWM {
private:

	void attach(int pin);
	int pwmChannel = 0;                         // channel number for this servo
	bool attachedState = false;
	int pin;
	uint8_t resolutionBits;
	double myFreq;
	int allocatenext(double freq);

	static double _ledcSetupTimerFreq(uint8_t pin, double freq,
			uint8_t bit_num);

	bool checkFrequencyForSideEffects(double freq);

	void adjustFrequencyLocal(double freq, double dutyScaled);
	static double mapf(double x, double in_min, double in_max, double out_min,
			double out_max) {
		if(x>in_max)
			return out_max;
		if(x<in_min)
			return out_min;
		return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	}

	double setup(double freq, uint8_t resolution_bits=10);
	//channel 0-15 resolution 1-16bits freq limits depend on resolution9
	void attachPin(uint8_t pin);
	// pin allocation
	void deallocate();
public:
	// setup
	ESP32PWM();
	virtual ~ESP32PWM();


	void detachPin(int pin);
	void attachPin(uint8_t pin, double freq, uint8_t resolution_bits=10);
	bool attached() {
		return attachedState;
	}

	// write raw duty cycle
	void write(uint32_t duty);
	// Write a duty cycle to the PWM using a unit vector from 0.0-1.0
	void writeScaled(double duty);
	//Adjust frequency
	double writeTone(double freq);
	double writeNote(note_t note, uint8_t octave);
	void adjustFrequency(double freq, double dutyScaled=-1);

	// Read pwm data
	uint32_t read();
	double readFreq();
	double getDutyScaled();

	//Timer data
	static int timerAndIndexToChannel(int timer, int index);
	/**
	 * allocateTimer
	 * @param a timer number 0-3 indicating which timer to allocate in this library
	 * Switch to explicate allocation mode
	 *
	 */
	static void allocateTimer(int timerNumber);
	static bool explicateAllocationMode;
	int getTimer() {
		return timerNum;
	}
	int timerNum = -1;
	uint32_t myDuty = 0;
	int getChannel();
	static int PWMCount;              // the total number of attached pwm
	static int timerCount[4];
	static ESP32PWM * ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
	static long timerFreqSet[4];

	// Helper functions
	int getPin() {
		return pin;
	}
	static bool hasPwm(int pin) {
#if defined(CONFIG_IDF_TARGET_ESP32S2)
		if ((pin >=1 && pin <= 21) || //21
				(pin == 26) || //1
				(pin >= 33 && pin <= 42)) //10
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
		if ((pin >=1 && pin <= 21) || //20
				(pin >= 35 && pin <= 45) || //11
				(pin == 47) || (pin == 48)) //2
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
		if ((pin >=0 && pin <= 10) || //11
				(pin >= 18 && pin <= 21)) //4
#elif defined(CONFIG_IDF_TARGET_ESP32C6)
		if ((pin >=0 && pin <= 9) || //10
				(pin >= 12 && pin <= 23)) //12
#elif defined(CONFIG_IDF_TARGET_ESP32H2)
		if ((pin >=0 && pin <= 5) || //6
				(pin >= 8 && pin <= 14) || //7
				(pin >= 22 && pin <= 27)) //6
#else
		if ((pin == 2) || //1
				(pin == 4) || //1
				(pin == 5) || //1
				((pin >= 12) && (pin <= 19)) || //8
				((pin >= 21) && (pin <= 23)) || //3
				((pin >= 25) && (pin <= 27)) || //3
				(pin == 32) || (pin == 33)) //2
#endif
			return true;
		return false;
	}
	static int channelsRemaining() {
		return NUM_PWM - PWMCount;
	}
	static boolean DISABLE_DAC;


};

ESP32PWM* pwmFactory(int pin);

#endif /* LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_ */

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32PWM.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32Servo.cpp ---

/*
Copyright (c) 2017 John K. Bennett. All right reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

* Notes on the implementation:
* The ESP32 supports 16 hardware LED PWM channels that are intended
* to be used for LED brightness control. The low level ESP32 code
* (esp32-hal-ledc.*) allows us to set the PWM frequency and bit-depth,
* and then manipulate them by setting bits in the relevant control
* registers.
*
* Different servos require different pulse widths to vary servo angle, but the range is
* an approximately 500-2500 microsecond pulse every 20ms (50Hz). In general, hobbyist servos
* sweep 180 degrees, so the lowest number in the published range for a particular servo
* represents an angle of 0 degrees, the middle of the range represents 90 degrees, and the top
* of the range represents 180 degrees. So for example, if the range is 1000us to 2000us,
* 1000us would equal an angle of 0, 1500us would equal 90 degrees, and 2000us would equal 180
* degrees. We vary pulse width (recall that the pulse period is already set to 20ms) as follows:
*
* The ESP32 PWM timers allow us to set the timer width (max 20 bits). Thus
* the timer "tick" length is (pulse_period/2**timer_width), and the equation for pulse_high_width
* (the portion of the 20ms cycle that the signal is high) becomes:
*
*                  pulse_high_width  = count * tick_length
*                                    = count * (pulse_period/2**timer_width)
*
*            and   count = (pulse_high_width / (pulse_period/2**timer_width))
*
* So, for example, if I want a 1500us pulse_high_width, I set pulse_period to 20ms (20000us)
* (this value is set in the ledcSetup call), and count (used in the ledcWrite call) to
* 1500/(20000/65536), or 4924. This is the value we write to the timer in the ledcWrite call.
* If we increase the timer_width, the timer_count values need to be adjusted.
*
* The servo signal pins connect to any available GPIO pins on the ESP32, but not all pins are
* GPIO pins.
*
* The ESP32 is a 32 bit processor that includes FP support; this code reflects that fact.
*/

#include <ESP32Servo.h>
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

static const char* TAG = "ESP32Servo";

Servo::Servo()
{		// initialize this channel with plausible values, except pin # (we set pin # when attached)
	REFRESH_CPS = 50;
	this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
	this->timer_width = DEFAULT_TIMER_WIDTH;
	this->pinNumber = -1;     // make it clear that we haven't attached a pin to this channel
	this->min = DEFAULT_uS_LOW;
	this->max = DEFAULT_uS_HIGH;
	this->timer_width_ticks = pow(2,this->timer_width);

}
ESP32PWM * Servo::getPwm(){

	return &pwm;
}

int Servo::attach(int pin)
{

    return (this->attach(pin, DEFAULT_uS_LOW, DEFAULT_uS_HIGH));
}

int Servo::attach(int pin, int min, int max)
{
    ESP_LOGW(TAG, "Attempting to Attach servo on pin=%d min=%d max=%d",pin,min,max);

#ifdef ENFORCE_PINS
        // ESP32 Recommend only the following pins 2,4,12-19,21-23,25-27,32-33
		// ESP32-S2 only the following pins 1-21,26,33-42
        if (pwm.hasPwm(pin))
        {
#endif

            // OK to proceed; first check for new/reuse
            if (this->pinNumber < 0) // we are attaching to a new or previously detached pin; we need to initialize/reinitialize
            {
                this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
                this->timer_width = DEFAULT_TIMER_WIDTH;
                this->timer_width_ticks = pow(2,this->timer_width);
            }
            this->pinNumber = pin;
#ifdef ENFORCE_PINS
        }
        else
        {
#ifdef __XTENSA_esp32s3__
if(
#endif

#if defined(CONFIG_IDF_TARGET_ESP32S2)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,26,33-42", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
			    ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,35-45,47-48", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-10,18-21", pin);
#else
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif
            return 0;
        }
#endif


        // min/max checks 
        if (min < MIN_PULSE_WIDTH)          // ensure pulse width is valid
            min = MIN_PULSE_WIDTH;
        if (max > MAX_PULSE_WIDTH)
            max = MAX_PULSE_WIDTH;
        this->min = min;     //store this value in uS
        this->max = max;    //store this value in uS
        // Set up this channel
        // if you want anything other than default timer width, you must call setTimerWidth() before attach

        pwm.attachPin(this->pinNumber,REFRESH_CPS, this->timer_width );   // GPIO pin assigned to channel
        ESP_LOGW(TAG, "Success to Attach servo : %d on PWM %d",pin,pwm.getChannel());

        return pwm.getChannel();
}

void Servo::detach()
{
    if (this->attached())
    {
        //keep track of detached servos channels so we can reuse them if needed
        pwm.detachPin(this->pinNumber);

        this->pinNumber = -1;
    }
}

void Servo::write(int value)
{
    // treat values less than MIN_PULSE_WIDTH (500) as angles in degrees (valid values in microseconds are handled as microseconds)
    if (value < MIN_PULSE_WIDTH)
    {
        if (value < 0)
            value = 0;
        else if (value > 180)
            value = 180;

        value = map(value, 0, 180, this->min, this->max);
    }
    this->writeMicroseconds(value);
}

void Servo::writeMicroseconds(int value)
{
    writeTicks(usToTicks(value));  // convert to ticks
}

void Servo::writeTicks(int value)
{
    // calculate and store the values for the given channel
    if (this->attached())   // ensure channel is valid
    {
        if (value < usToTicks(this->min))      // ensure ticks are in range
            value = usToTicks(this->min);
        else if (value > usToTicks(this->max))
            value = usToTicks(this->max);
        this->ticks = value;
        // do the actual write
        pwm.write( this->ticks);
    }
}

void Servo::release()
{
    if (this->attached())   // ensure channel is valid
        pwm.write(0);
}

int Servo::read() // return the value as degrees
{
    return (map(readMicroseconds(), this->min, this->max, 0, 180));
}

int Servo::readMicroseconds()
{
    int pulsewidthUsec;
    if (this->attached())
    { 
        pulsewidthUsec = ticksToUs(this->ticks);
    }
    else
    {
        pulsewidthUsec = 0;
    }

    return (pulsewidthUsec);
}

int Servo::readTicks()
{
    return this->ticks;
}

bool Servo::attached()
{
    return (pwm.attached());
}

void Servo::setTimerWidth(int value)
{
    // only allow values between 10 and 14 for ESP32-C3
    // only allow values between 16 and 20 for other ESP32
    if (value < MINIMUM_TIMER_WIDTH )
        value = MINIMUM_TIMER_WIDTH;
    else if (value > MAXIMUM_TIMER_WIDTH)
        value = MAXIMUM_TIMER_WIDTH;
        
    // Fix the current ticks value after timer width change
    // The user can reset the tick value with a write() or writeUs()
    int widthDifference = this->timer_width - value;
    // if positive multiply by diff; if neg, divide
    if (widthDifference > 0)
    {
        this->ticks = widthDifference * this->ticks;
    }
    else if (widthDifference < 0)
    {
        this->ticks = this->ticks/-widthDifference;
    }
    
    this->timer_width = value;
    this->timer_width_ticks = pow(2,this->timer_width);
    
    // If this is an attached servo, clean up
    if (this->attached())
    {
        // detach, setup and attach again to reflect new timer width
    	pwm.detachPin(this->pinNumber);
    	pwm.attachPin(this->pinNumber, REFRESH_CPS, this->timer_width);
    }        
}

int Servo::readTimerWidth()
{
    return (this->timer_width);
}

int Servo::usToTicks(int usec)
{
    return (int)((double)usec / ((double)REFRESH_USEC / (double)this->timer_width_ticks)*(((double)REFRESH_CPS)/50.0));
}

int Servo::ticksToUs(int ticks)
{
    return (int)((double)ticks * ((double)REFRESH_USEC / (double)this->timer_width_ticks)/(((double)REFRESH_CPS)/50.0));
}

 

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32Servo.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32Servo.h ---

/*
 Copyright (c) 2017 John K. Bennett. All right reserved.

 ESP32_Servo.h - Servo library for ESP32 - Version 1

 Original Servo.h written by Michael Margolis in 2009

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/* 
 A servo is activated by creating an instance of the Servo class, and passing
 the desired GPIO pin to the attach() method.
 The servos are pulsed in the background using the value most recently
 written using the write() method.

 The class methods are:

 Servo - Class for manipulating servo motors connected to ESP32 pins.
 int attach(pin )  - Attaches the given GPIO pin to the next free channel
 (channels that have previously been detached are used first),
 returns channel number or 0 if failure. All pin numbers are allowed,
 but only pins 2,4,12-19,21-23,25-27,32-33 are recommended.
 int attach(pin, min, max  ) - Attaches to a pin setting min and max
 values in microseconds; enforced minimum min is 500, enforced max
 is 2500. Other semantics same as attach().
 void write () - Sets the servo angle in degrees; a value below 500 is
 treated as a value in degrees (0 to 180). These limit are enforced,
 i.e., values are treated as follows:
 Value                                   Becomes
 -----                                   -------
 < 0                                        0
 0 - 180                             value (treated as degrees)
 181 - 499                                 180
 500 - (min-1)                             min
 min-max (from attach or default)    value (treated as microseconds)
 (max+1) - 2500                            max

 void writeMicroseconds() - Sets the servo pulse width in microseconds.
 min and max are enforced (see above).
 int read() - Gets the last written servo pulse width as an angle between 0 and 180.
 int readMicroseconds()   - Gets the last written servo pulse width in microseconds.
 bool attached() - Returns true if this servo instance is attached.
 void detach() - Stops an the attached servo, frees its attached pin, and frees
 its channel for reuse).

 *** ESP32-specific functions **
 setTimerWidth(value) - Sets the PWM timer width (must be 16-20) (ESP32 ONLY);
 as a side effect, the pulse width is recomputed.
 int readTimerWidth() - Gets the PWM timer width (ESP32 ONLY)
 */

#ifndef ESP32_Servo_h
#define ESP32_Servo_h
//#include "analogWrite.h"
#include "ESP32PWM.h"
//#include "ESP32Tone.h"
//Enforce only using PWM pins on the ESP32
#define ENFORCE_PINS
// Default Arduino Servo.h
#define DEFAULT_uS_LOW 544
#define DEFAULT_uS_HIGH 2400

// Values for TowerPro MG995 large servos (and many other hobbyist servos)
//#define DEFAULT_uS_LOW 1000        // 1000us
//#define DEFAULT_uS_HIGH 2000      // 2000us

// Values for TowerPro SG90 small servos
//#define DEFAULT_uS_LOW 400
//#define DEFAULT_uS_HIGH 2400

#ifdef ARDUINO_ESP32C3_DEV
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 14
#define DEFAULT_TIMER_WIDTH 10
#else
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 20
#define DEFAULT_TIMER_WIDTH 10
#endif
#define DEFAULT_TIMER_WIDTH_TICKS 1024

#define ESP32_Servo_VERSION           1     // software version of this library

#define MIN_PULSE_WIDTH       500     // the shortest pulse sent to a servo  
#define MAX_PULSE_WIDTH      2500     // the longest pulse sent to a servo 
#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
#define DEFAULT_PULSE_WIDTH_TICKS 4825
//#define REFRESH_CPS            50
#define REFRESH_USEC         20000

#define MAX_SERVOS              16     // no. of PWM channels in ESP32

/*
 * This group/channel/timmer mapping is for information only;
 * the details are handled by lower-level code
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

class Servo {

public:
	Servo();
	// Arduino Servo Library calls
	int attach(int pin); // attach the given pin to the next free channel, returns channel number or 0 if failure
	int attach(int pin, int min, int max); // as above but also sets min and max values for writes.
	void detach();
	void write(int value); // if value is < MIN_PULSE_WIDTH its treated as an angle, otherwise as pulse width in microseconds
	void writeMicroseconds(int value);     // Write pulse width in microseconds
	void writeTicks(int value);     // Write ticks, the smallest increment the servo can handle
	void release();
	int read(); // returns current pulse width as an angle between 0 and 180 degrees
	int readMicroseconds(); // returns current pulse width in microseconds for this servo
	int readTicks(); // returns current ticks, the smallest increment the servo can handle
	bool attached(); // return true if this servo is attached, otherwise false

	// ESP32 only functions
	void setTimerWidth(int value);     // set the PWM timer width (ESP32 ONLY)
	int readTimerWidth();              // get the PWM timer width (ESP32 ONLY)
	void setPeriodHertz(int hertz){
		REFRESH_CPS=hertz;
		setTimerWidth(this->timer_width);
	}
private:
	int usToTicks(int usec);
	int ticksToUs(int ticks);
//   static int ServoCount;                             // the total number of attached servos
//   static int ChannelUsed[];                          // used to track whether a channel is in service
//   int servoChannel = 0;                              // channel number for this servo

	int min = DEFAULT_uS_LOW;           // minimum pulse width for this servo
	int max = DEFAULT_uS_HIGH;            // maximum pulse width for this servo
	int pinNumber = 0;                      // GPIO pin assigned to this channel
	int timer_width = DEFAULT_TIMER_WIDTH; // ESP32 allows variable width PWM timers
	int ticks = DEFAULT_PULSE_WIDTH_TICKS; // current pulse width on this channel
	int timer_width_ticks = DEFAULT_TIMER_WIDTH_TICKS; // no. of ticks at rollover; varies with width
	ESP32PWM * getPwm(); // get the PWM object
	ESP32PWM pwm;
	int REFRESH_CPS = 50;

};
#endif

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\esp32dev\ESP32Servo\src\ESP32Servo.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32PWM.cpp ---

/*
 * ESP32PWM.cpp
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#include <ESP32PWM.h>
#include "esp32-hal-ledc.h"

// initialize the class variable ServoCount
int ESP32PWM::PWMCount = -1;              // the total number of attached servos
bool  ESP32PWM::explicateAllocationMode=false;
ESP32PWM * ESP32PWM::ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
long ESP32PWM::timerFreqSet[4] = { -1, -1, -1, -1 };
int ESP32PWM::timerCount[4] = { 0, 0, 0, 0 };

static const char* TAG = "ESP32PWM";

// The ChannelUsed array elements are 0 if never used, 1 if in use, and -1 if used and disposed
// (i.e., available for reuse)
/**
 * allocateTimer
 * @param a timer number 0-3 indicating which timer to allocate in this library
 * Switch to explicate allocation mode
 *
 */
void ESP32PWM::allocateTimer(int timerNumber){
	if(timerNumber<0 || timerNumber>3)
		return;
	if(ESP32PWM::explicateAllocationMode==false){
		ESP32PWM::explicateAllocationMode=true;
		for(int i=0;i<4;i++)
			ESP32PWM::timerCount[i]=4;// deallocate all timers to start mode
	}
	ESP32PWM::timerCount[timerNumber]=0;
}

ESP32PWM::ESP32PWM() {
	resolutionBits = 8;
	pwmChannel = -1;
	pin = -1;
	myFreq = -1;
	if (PWMCount == -1) {
		for (int i = 0; i < NUM_PWM; i++)
			ChannelUsed[i] = NULL; // load invalid data into the storage array of pin mapping
		PWMCount = PWM_BASE_INDEX; // 0th channel does not work with the PWM system
	}
}

ESP32PWM::~ESP32PWM() {
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
#else
		ledcDetachPin(pin);
#endif
#else
		ledcDetachPin(pin);
#endif
	}
	deallocate();
}

double ESP32PWM::_ledcSetupTimerFreq(uint8_t pin, double freq,
		uint8_t bit_num) {

#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(pin, freq, bit_num);
#else
	return ledcSetup(pin, freq, bit_num);
#endif
#else
	return ledcSetup(pin, freq, bit_num);
#endif

}

int ESP32PWM::timerAndIndexToChannel(int timerNum, int index) {
	int localIndex = 0;
	for (int j = 0; j < NUM_PWM; j++) {
		if (((j / 2) % 4) == timerNum) {
			if (localIndex == index) {
				return j;
			}
			localIndex++;
		}
	}
	return -1;
}
int ESP32PWM::allocatenext(double freq) {
	long freqlocal = (long) freq;
	if (pwmChannel < 0) {
		for (int i = 0; i < 4; i++) {
			bool freqAllocated = ((timerFreqSet[i] == freqlocal)
					|| (timerFreqSet[i] == -1));
			if (freqAllocated && timerCount[i] < 4) {
				if (timerFreqSet[i] == -1) {
					//Serial.println("Starting timer "+String(i)+" at freq "+String(freq));
					timerFreqSet[i] = freqlocal;
				}
				//Serial.println("Free channel timer "+String(i)+" at freq "+String(freq)+" remaining "+String(4-timerCount[i]));

				timerNum = i;
				for (int index=0; index<4; ++index)
				{
					int myTimerNumber = timerAndIndexToChannel(timerNum,index);
					if ((myTimerNumber >= 0)  && (!ChannelUsed[myTimerNumber]))
					{
						pwmChannel = myTimerNumber;
// 						Serial.println(
// 							"PWM on ledc channel #" + String(pwmChannel)
// 									+ " using 'timer " + String(timerNum)
// 									+ "' to freq " + String(freq) + "Hz");
						ChannelUsed[pwmChannel] = this;
						timerCount[timerNum]++;
						PWMCount++;
						myFreq = freq;
						return pwmChannel;
					}
				}
			} else {
//				if(timerFreqSet[i]>0)
//					Serial.println("Timer freq mismatch target="+String(freq)+" on timer "+String(i)+" was "+String(timerFreqSet[i]));
//				else
//					Serial.println("Timer out of channels target="+String(freq)+" on timer "+String(i)+" was "+String(timerCount[i]));
			}
		}
	} else {
		return pwmChannel;
	}
	ESP_LOGE(TAG, 
			"ERROR All PWM timers allocated! Can't accomodate %d Hz\r\nHalting...", freq);
	while (1)
		;
}
void ESP32PWM::deallocate() {
	if (pwmChannel < 0)
		return;
	ESP_LOGE(TAG, "PWM deallocating LEDc #%d",pwmChannel);
	timerCount[getTimer()]--;
	if (timerCount[getTimer()] == 0) {
		timerFreqSet[getTimer()] = -1; // last pwn closed out
	}
	timerNum = -1;
	attachedState = false;
	ChannelUsed[pwmChannel] = NULL;
	pwmChannel = -1;
	PWMCount--;

}

int ESP32PWM::getChannel() {
	if (pwmChannel < 0) {
		ESP_LOGE(TAG, "FAIL! must setup() before using get channel!");
	}
	return pwmChannel;
}

double ESP32PWM::setup(double freq, uint8_t resolution_bits) {
	checkFrequencyForSideEffects(freq);

	resolutionBits = resolution_bits;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		double val = ledcAttach(getPin(), freq, resolution_bits);
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
		ledcDetachPin(pin);
		double val = ledcSetup(getChannel(), freq, resolution_bits);
#endif

		attachPin(pin);
		return val;
	}
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcAttach(getPin(), freq, resolution_bits);
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
#else
	return ledcSetup(getChannel(), freq, resolution_bits);
#endif
}
double ESP32PWM::getDutyScaled() {
	return mapf((double) myDuty, 0, (double) ((1 << resolutionBits) - 1), 0.0,
			1.0);
}
void ESP32PWM::writeScaled(double duty) {
	write(mapf(duty, 0.0, 1.0, 0, (double) ((1 << resolutionBits) - 1)));
}
void ESP32PWM::write(uint32_t duty) {
	myDuty = duty;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	ledcWrite(getPin(), duty);
#else
	ledcWrite(getChannel(), duty);
#endif
#else
	ledcWrite(getChannel(), duty);
#endif
}
void ESP32PWM::adjustFrequencyLocal(double freq, double dutyScaled) {
	timerFreqSet[getTimer()] = (long) freq;
	myFreq = freq;
	if (attached()) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		ledcDetach(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttach(getPin(), freq, resolutionBits); // re-attach the pin after frequency adjust
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif
#else
		ledcDetachPin(pin);
		// Remove the PWM during frequency adjust
		_ledcSetupTimerFreq(getChannel(), freq, resolutionBits);
		writeScaled(dutyScaled);
		ledcAttachPin(pin, getChannel()); // re-attach the pin after frequency adjust
#endif

	} else {
		_ledcSetupTimerFreq(getPin(), freq, resolutionBits);
		writeScaled(dutyScaled);
	}
}
void ESP32PWM::adjustFrequency(double freq, double dutyScaled) {
	if(dutyScaled<0)
		dutyScaled=getDutyScaled();
	writeScaled(dutyScaled);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
		}
	}
}
double ESP32PWM::writeTone(double freq) {
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);
		if (ChannelUsed[pwm] != NULL) {
			if (ChannelUsed[pwm]->myFreq != freq) {
				ChannelUsed[pwm]->adjustFrequencyLocal(freq,
						ChannelUsed[pwm]->getDutyScaled());
			}
			write(1 << (resolutionBits-1)); // writeScaled(0.5);
		}
	}

	return 0;
}
double ESP32PWM::writeNote(note_t note, uint8_t octave) {
	const uint16_t noteFrequencyBase[12] = {
			//   C        C#       D        Eb       E        F       F#        G       G#        A       Bb        B
			4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459,
			7902 };

	if (octave > 8 || note >= NOTE_MAX) {
		return 0;
	}
	double noteFreq = (double) noteFrequencyBase[note]
			/ (double) (1 << (8 - octave));
	return writeTone(noteFreq);
}
uint32_t ESP32PWM::read() {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
	return ledcRead(getPin());
#else
	return ledcRead(getChannel());
#endif
#else
	return ledcRead(getChannel());
#endif

}
double ESP32PWM::readFreq() {
	return myFreq;
}
void ESP32PWM::attach(int p) {
	pin = p;
	attachedState = true;
}
void ESP32PWM::attachPin(uint8_t pin) {

	if (hasPwm(pin)) {
		attach(pin);
		bool success=true;
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)
		success=ledcAttach(pin, readFreq(), resolutionBits);
#else
		ledcAttachPin(pin, getChannel());
#endif
#else
		ledcAttachPin(pin, getChannel());
#endif
		if(success)
			return;
		ESP_LOGE(TAG, "ERROR PWM channel failed to configure on!",pin);
		return;
	}
		
#if defined(CONFIG_IDF_TARGET_ESP32S2)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,26,33-42",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-21,35-45,47-48",pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 1-10,18-21",pin);
#else
						ESP_LOGE(TAG, "ERROR PWM channel unavailable on pin requested! %d PWM available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif

}
void ESP32PWM::attachPin(uint8_t pin, double freq, uint8_t resolution_bits) {

	if (hasPwm(pin)){
		int ret=setup(freq, resolution_bits);
		ESP_LOGW(TAG, "Pin Setup %d with code %d",pin,ret);
	}
	else
		ESP_LOGE(TAG, "ERROR Pin Failed %d ",pin);
	attachPin(pin);
}
void ESP32PWM::detachPin(int pin) {
#ifdef ESP_ARDUINO_VERSION_MAJOR
#if ESP_ARDUINO_VERSION >= ESP_ARDUINO_VERSION_VAL(3, 0, 0)

	ledcDetach(pin);
#else
	ledcDetachPin(pin);
#endif
#else
	ledcDetachPin(pin);
#endif
	deallocate();
}
/* Side effects of frequency changes happen because of shared timers
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

bool ESP32PWM::checkFrequencyForSideEffects(double freq) {

	allocatenext(freq);
	for (int i = 0; i < timerCount[getTimer()]; i++) {
		int pwm = timerAndIndexToChannel(getTimer(), i);

		if (pwm == pwmChannel)
			continue;
		if (ChannelUsed[pwm] != NULL)
			if (ChannelUsed[pwm]->getTimer() == getTimer()) {
				double diff = abs(ChannelUsed[pwm]->myFreq - freq);
				if (abs(diff) > 0.1) {
					ESP_LOGW(TAG, 
							"\tWARNING PWM channel %d	\
							 shares a timer with channel %d\n	\
							\tchanging the frequency to %d		\
							Hz will ALSO change channel %d	\
							\n\tfrom its previous frequency of %d Hz\n "
								,pwmChannel, pwm, freq,pwm, ChannelUsed[pwm]->myFreq);
					ChannelUsed[pwm]->myFreq = freq;
				}
			}
	}
	return true;
}

ESP32PWM* pwmFactory(int pin) {
	for (int i = 0; i < NUM_PWM; i++)
		if (ESP32PWM::ChannelUsed[i] != NULL) {
			if (ESP32PWM::ChannelUsed[i]->getPin() == pin)
				return ESP32PWM::ChannelUsed[i];
		}
	return NULL;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32PWM.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32PWM.h ---

/*
 * ESP32PWM.h
 *
 *  Created on: Sep 22, 2018
 *      Author: hephaestus
 */

#ifndef LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#define LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_
#include "esp32-hal-ledc.h"
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

#if defined(CONFIG_IDF_TARGET_ESP32C3)
#define NUM_PWM 6
#elif defined(CONFIG_IDF_TARGET_ESP32S2)   ||  defined(CONFIG_IDF_TARGET_ESP32S3)
#define NUM_PWM 8
#else 
#define NUM_PWM 16
#endif

#define PWM_BASE_INDEX 0
#define USABLE_ESP32_PWM (NUM_PWM-PWM_BASE_INDEX)
#include <cstdint>

class ESP32PWM {
private:

	void attach(int pin);
	int pwmChannel = 0;                         // channel number for this servo
	bool attachedState = false;
	int pin;
	uint8_t resolutionBits;
	double myFreq;
	int allocatenext(double freq);

	static double _ledcSetupTimerFreq(uint8_t pin, double freq,
			uint8_t bit_num);

	bool checkFrequencyForSideEffects(double freq);

	void adjustFrequencyLocal(double freq, double dutyScaled);
	static double mapf(double x, double in_min, double in_max, double out_min,
			double out_max) {
		if(x>in_max)
			return out_max;
		if(x<in_min)
			return out_min;
		return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	}

	double setup(double freq, uint8_t resolution_bits=10);
	//channel 0-15 resolution 1-16bits freq limits depend on resolution9
	void attachPin(uint8_t pin);
	// pin allocation
	void deallocate();
public:
	// setup
	ESP32PWM();
	virtual ~ESP32PWM();


	void detachPin(int pin);
	void attachPin(uint8_t pin, double freq, uint8_t resolution_bits=10);
	bool attached() {
		return attachedState;
	}

	// write raw duty cycle
	void write(uint32_t duty);
	// Write a duty cycle to the PWM using a unit vector from 0.0-1.0
	void writeScaled(double duty);
	//Adjust frequency
	double writeTone(double freq);
	double writeNote(note_t note, uint8_t octave);
	void adjustFrequency(double freq, double dutyScaled=-1);

	// Read pwm data
	uint32_t read();
	double readFreq();
	double getDutyScaled();

	//Timer data
	static int timerAndIndexToChannel(int timer, int index);
	/**
	 * allocateTimer
	 * @param a timer number 0-3 indicating which timer to allocate in this library
	 * Switch to explicate allocation mode
	 *
	 */
	static void allocateTimer(int timerNumber);
	static bool explicateAllocationMode;
	int getTimer() {
		return timerNum;
	}
	int timerNum = -1;
	uint32_t myDuty = 0;
	int getChannel();
	static int PWMCount;              // the total number of attached pwm
	static int timerCount[4];
	static ESP32PWM * ChannelUsed[NUM_PWM]; // used to track whether a channel is in service
	static long timerFreqSet[4];

	// Helper functions
	int getPin() {
		return pin;
	}
	static bool hasPwm(int pin) {
#if defined(CONFIG_IDF_TARGET_ESP32S2)
		if ((pin >=1 && pin <= 21) || //21
				(pin == 26) || //1
				(pin >= 33 && pin <= 42)) //10
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
		if ((pin >=1 && pin <= 21) || //20
				(pin >= 35 && pin <= 45) || //11
				(pin == 47) || (pin == 48)) //2
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
		if ((pin >=0 && pin <= 10) || //11
				(pin >= 18 && pin <= 21)) //4
#elif defined(CONFIG_IDF_TARGET_ESP32C6)
		if ((pin >=0 && pin <= 9) || //10
				(pin >= 12 && pin <= 23)) //12
#elif defined(CONFIG_IDF_TARGET_ESP32H2)
		if ((pin >=0 && pin <= 5) || //6
				(pin >= 8 && pin <= 14) || //7
				(pin >= 22 && pin <= 27)) //6
#else
		if ((pin == 2) || //1
				(pin == 4) || //1
				(pin == 5) || //1
				((pin >= 12) && (pin <= 19)) || //8
				((pin >= 21) && (pin <= 23)) || //3
				((pin >= 25) && (pin <= 27)) || //3
				(pin == 32) || (pin == 33)) //2
#endif
			return true;
		return false;
	}
	static int channelsRemaining() {
		return NUM_PWM - PWMCount;
	}
	static boolean DISABLE_DAC;


};

ESP32PWM* pwmFactory(int pin);

#endif /* LIBRARIES_ESP32SERVO_SRC_ESP32PWM_H_ */

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32PWM.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32Servo.cpp ---

/*
Copyright (c) 2017 John K. Bennett. All right reserved.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA

* Notes on the implementation:
* The ESP32 supports 16 hardware LED PWM channels that are intended
* to be used for LED brightness control. The low level ESP32 code
* (esp32-hal-ledc.*) allows us to set the PWM frequency and bit-depth,
* and then manipulate them by setting bits in the relevant control
* registers.
*
* Different servos require different pulse widths to vary servo angle, but the range is
* an approximately 500-2500 microsecond pulse every 20ms (50Hz). In general, hobbyist servos
* sweep 180 degrees, so the lowest number in the published range for a particular servo
* represents an angle of 0 degrees, the middle of the range represents 90 degrees, and the top
* of the range represents 180 degrees. So for example, if the range is 1000us to 2000us,
* 1000us would equal an angle of 0, 1500us would equal 90 degrees, and 2000us would equal 180
* degrees. We vary pulse width (recall that the pulse period is already set to 20ms) as follows:
*
* The ESP32 PWM timers allow us to set the timer width (max 20 bits). Thus
* the timer "tick" length is (pulse_period/2**timer_width), and the equation for pulse_high_width
* (the portion of the 20ms cycle that the signal is high) becomes:
*
*                  pulse_high_width  = count * tick_length
*                                    = count * (pulse_period/2**timer_width)
*
*            and   count = (pulse_high_width / (pulse_period/2**timer_width))
*
* So, for example, if I want a 1500us pulse_high_width, I set pulse_period to 20ms (20000us)
* (this value is set in the ledcSetup call), and count (used in the ledcWrite call) to
* 1500/(20000/65536), or 4924. This is the value we write to the timer in the ledcWrite call.
* If we increase the timer_width, the timer_count values need to be adjusted.
*
* The servo signal pins connect to any available GPIO pins on the ESP32, but not all pins are
* GPIO pins.
*
* The ESP32 is a 32 bit processor that includes FP support; this code reflects that fact.
*/

#include <ESP32Servo.h>
#if defined(ARDUINO)
	#include "Arduino.h"
#endif

static const char* TAG = "ESP32Servo";

Servo::Servo()
{		// initialize this channel with plausible values, except pin # (we set pin # when attached)
	REFRESH_CPS = 50;
	this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
	this->timer_width = DEFAULT_TIMER_WIDTH;
	this->pinNumber = -1;     // make it clear that we haven't attached a pin to this channel
	this->min = DEFAULT_uS_LOW;
	this->max = DEFAULT_uS_HIGH;
	this->timer_width_ticks = pow(2,this->timer_width);

}
ESP32PWM * Servo::getPwm(){

	return &pwm;
}

int Servo::attach(int pin)
{

    return (this->attach(pin, DEFAULT_uS_LOW, DEFAULT_uS_HIGH));
}

int Servo::attach(int pin, int min, int max)
{
    ESP_LOGW(TAG, "Attempting to Attach servo on pin=%d min=%d max=%d",pin,min,max);

#ifdef ENFORCE_PINS
        // ESP32 Recommend only the following pins 2,4,12-19,21-23,25-27,32-33
		// ESP32-S2 only the following pins 1-21,26,33-42
        if (pwm.hasPwm(pin))
        {
#endif

            // OK to proceed; first check for new/reuse
            if (this->pinNumber < 0) // we are attaching to a new or previously detached pin; we need to initialize/reinitialize
            {
                this->ticks = DEFAULT_PULSE_WIDTH_TICKS;
                this->timer_width = DEFAULT_TIMER_WIDTH;
                this->timer_width_ticks = pow(2,this->timer_width);
            }
            this->pinNumber = pin;
#ifdef ENFORCE_PINS
        }
        else
        {
#ifdef __XTENSA_esp32s3__
if(
#endif

#if defined(CONFIG_IDF_TARGET_ESP32S2)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,26,33-42", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32S3)
			    ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-21,35-45,47-48", pin);
#elif defined(CONFIG_IDF_TARGET_ESP32C3)
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 1-10,18-21", pin);
#else
				ESP_LOGE(TAG, "This pin can not be a servo: %d Servo available on: 2,4,5,12-19,21-23,25-27,32-33",pin);
#endif
            return 0;
        }
#endif


        // min/max checks 
        if (min < MIN_PULSE_WIDTH)          // ensure pulse width is valid
            min = MIN_PULSE_WIDTH;
        if (max > MAX_PULSE_WIDTH)
            max = MAX_PULSE_WIDTH;
        this->min = min;     //store this value in uS
        this->max = max;    //store this value in uS
        // Set up this channel
        // if you want anything other than default timer width, you must call setTimerWidth() before attach

        pwm.attachPin(this->pinNumber,REFRESH_CPS, this->timer_width );   // GPIO pin assigned to channel
        ESP_LOGW(TAG, "Success to Attach servo : %d on PWM %d",pin,pwm.getChannel());

        return pwm.getChannel();
}

void Servo::detach()
{
    if (this->attached())
    {
        //keep track of detached servos channels so we can reuse them if needed
        pwm.detachPin(this->pinNumber);

        this->pinNumber = -1;
    }
}

void Servo::write(int value)
{
    // treat values less than MIN_PULSE_WIDTH (500) as angles in degrees (valid values in microseconds are handled as microseconds)
    if (value < MIN_PULSE_WIDTH)
    {
        if (value < 0)
            value = 0;
        else if (value > 180)
            value = 180;

        value = map(value, 0, 180, this->min, this->max);
    }
    this->writeMicroseconds(value);
}

void Servo::writeMicroseconds(int value)
{
    writeTicks(usToTicks(value));  // convert to ticks
}

void Servo::writeTicks(int value)
{
    // calculate and store the values for the given channel
    if (this->attached())   // ensure channel is valid
    {
        if (value < usToTicks(this->min))      // ensure ticks are in range
            value = usToTicks(this->min);
        else if (value > usToTicks(this->max))
            value = usToTicks(this->max);
        this->ticks = value;
        // do the actual write
        pwm.write( this->ticks);
    }
}

void Servo::release()
{
    if (this->attached())   // ensure channel is valid
        pwm.write(0);
}

int Servo::read() // return the value as degrees
{
    return (map(readMicroseconds(), this->min, this->max, 0, 180));
}

int Servo::readMicroseconds()
{
    int pulsewidthUsec;
    if (this->attached())
    { 
        pulsewidthUsec = ticksToUs(this->ticks);
    }
    else
    {
        pulsewidthUsec = 0;
    }

    return (pulsewidthUsec);
}

int Servo::readTicks()
{
    return this->ticks;
}

bool Servo::attached()
{
    return (pwm.attached());
}

void Servo::setTimerWidth(int value)
{
    // only allow values between 10 and 14 for ESP32-C3
    // only allow values between 16 and 20 for other ESP32
    if (value < MINIMUM_TIMER_WIDTH )
        value = MINIMUM_TIMER_WIDTH;
    else if (value > MAXIMUM_TIMER_WIDTH)
        value = MAXIMUM_TIMER_WIDTH;
        
    // Fix the current ticks value after timer width change
    // The user can reset the tick value with a write() or writeUs()
    int widthDifference = this->timer_width - value;
    // if positive multiply by diff; if neg, divide
    if (widthDifference > 0)
    {
        this->ticks = widthDifference * this->ticks;
    }
    else if (widthDifference < 0)
    {
        this->ticks = this->ticks/-widthDifference;
    }
    
    this->timer_width = value;
    this->timer_width_ticks = pow(2,this->timer_width);
    
    // If this is an attached servo, clean up
    if (this->attached())
    {
        // detach, setup and attach again to reflect new timer width
    	pwm.detachPin(this->pinNumber);
    	pwm.attachPin(this->pinNumber, REFRESH_CPS, this->timer_width);
    }        
}

int Servo::readTimerWidth()
{
    return (this->timer_width);
}

int Servo::usToTicks(int usec)
{
    return (int)((double)usec / ((double)REFRESH_USEC / (double)this->timer_width_ticks)*(((double)REFRESH_CPS)/50.0));
}

int Servo::ticksToUs(int ticks)
{
    return (int)((double)ticks * ((double)REFRESH_USEC / (double)this->timer_width_ticks)/(((double)REFRESH_CPS)/50.0));
}

 

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32Servo.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32Servo.h ---

/*
 Copyright (c) 2017 John K. Bennett. All right reserved.

 ESP32_Servo.h - Servo library for ESP32 - Version 1

 Original Servo.h written by Michael Margolis in 2009

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/* 
 A servo is activated by creating an instance of the Servo class, and passing
 the desired GPIO pin to the attach() method.
 The servos are pulsed in the background using the value most recently
 written using the write() method.

 The class methods are:

 Servo - Class for manipulating servo motors connected to ESP32 pins.
 int attach(pin )  - Attaches the given GPIO pin to the next free channel
 (channels that have previously been detached are used first),
 returns channel number or 0 if failure. All pin numbers are allowed,
 but only pins 2,4,12-19,21-23,25-27,32-33 are recommended.
 int attach(pin, min, max  ) - Attaches to a pin setting min and max
 values in microseconds; enforced minimum min is 500, enforced max
 is 2500. Other semantics same as attach().
 void write () - Sets the servo angle in degrees; a value below 500 is
 treated as a value in degrees (0 to 180). These limit are enforced,
 i.e., values are treated as follows:
 Value                                   Becomes
 -----                                   -------
 < 0                                        0
 0 - 180                             value (treated as degrees)
 181 - 499                                 180
 500 - (min-1)                             min
 min-max (from attach or default)    value (treated as microseconds)
 (max+1) - 2500                            max

 void writeMicroseconds() - Sets the servo pulse width in microseconds.
 min and max are enforced (see above).
 int read() - Gets the last written servo pulse width as an angle between 0 and 180.
 int readMicroseconds()   - Gets the last written servo pulse width in microseconds.
 bool attached() - Returns true if this servo instance is attached.
 void detach() - Stops an the attached servo, frees its attached pin, and frees
 its channel for reuse).

 *** ESP32-specific functions **
 setTimerWidth(value) - Sets the PWM timer width (must be 16-20) (ESP32 ONLY);
 as a side effect, the pulse width is recomputed.
 int readTimerWidth() - Gets the PWM timer width (ESP32 ONLY)
 */

#ifndef ESP32_Servo_h
#define ESP32_Servo_h
//#include "analogWrite.h"
#include "ESP32PWM.h"
//#include "ESP32Tone.h"
//Enforce only using PWM pins on the ESP32
#define ENFORCE_PINS
// Default Arduino Servo.h
#define DEFAULT_uS_LOW 544
#define DEFAULT_uS_HIGH 2400

// Values for TowerPro MG995 large servos (and many other hobbyist servos)
//#define DEFAULT_uS_LOW 1000        // 1000us
//#define DEFAULT_uS_HIGH 2000      // 2000us

// Values for TowerPro SG90 small servos
//#define DEFAULT_uS_LOW 400
//#define DEFAULT_uS_HIGH 2400

#ifdef ARDUINO_ESP32C3_DEV
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 14
#define DEFAULT_TIMER_WIDTH 10
#else
#define MINIMUM_TIMER_WIDTH 10
#define MAXIMUM_TIMER_WIDTH 20
#define DEFAULT_TIMER_WIDTH 10
#endif
#define DEFAULT_TIMER_WIDTH_TICKS 1024

#define ESP32_Servo_VERSION           1     // software version of this library

#define MIN_PULSE_WIDTH       500     // the shortest pulse sent to a servo  
#define MAX_PULSE_WIDTH      2500     // the longest pulse sent to a servo 
#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached
#define DEFAULT_PULSE_WIDTH_TICKS 4825
//#define REFRESH_CPS            50
#define REFRESH_USEC         20000

#define MAX_SERVOS              16     // no. of PWM channels in ESP32

/*
 * This group/channel/timmer mapping is for information only;
 * the details are handled by lower-level code
 *
 * LEDC Chan to Group/Channel/Timer Mapping
 ** ledc: 0  => Group: 0, Channel: 0, Timer: 0
 ** ledc: 1  => Group: 0, Channel: 1, Timer: 0
 ** ledc: 2  => Group: 0, Channel: 2, Timer: 1
 ** ledc: 3  => Group: 0, Channel: 3, Timer: 1
 ** ledc: 4  => Group: 0, Channel: 4, Timer: 2
 ** ledc: 5  => Group: 0, Channel: 5, Timer: 2
 ** ledc: 6  => Group: 0, Channel: 6, Timer: 3
 ** ledc: 7  => Group: 0, Channel: 7, Timer: 3
 ** ledc: 8  => Group: 1, Channel: 0, Timer: 0
 ** ledc: 9  => Group: 1, Channel: 1, Timer: 0
 ** ledc: 10 => Group: 1, Channel: 2, Timer: 1
 ** ledc: 11 => Group: 1, Channel: 3, Timer: 1
 ** ledc: 12 => Group: 1, Channel: 4, Timer: 2
 ** ledc: 13 => Group: 1, Channel: 5, Timer: 2
 ** ledc: 14 => Group: 1, Channel: 6, Timer: 3
 ** ledc: 15 => Group: 1, Channel: 7, Timer: 3
 */

class Servo {

public:
	Servo();
	// Arduino Servo Library calls
	int attach(int pin); // attach the given pin to the next free channel, returns channel number or 0 if failure
	int attach(int pin, int min, int max); // as above but also sets min and max values for writes.
	void detach();
	void write(int value); // if value is < MIN_PULSE_WIDTH its treated as an angle, otherwise as pulse width in microseconds
	void writeMicroseconds(int value);     // Write pulse width in microseconds
	void writeTicks(int value);     // Write ticks, the smallest increment the servo can handle
	void release();
	int read(); // returns current pulse width as an angle between 0 and 180 degrees
	int readMicroseconds(); // returns current pulse width in microseconds for this servo
	int readTicks(); // returns current ticks, the smallest increment the servo can handle
	bool attached(); // return true if this servo is attached, otherwise false

	// ESP32 only functions
	void setTimerWidth(int value);     // set the PWM timer width (ESP32 ONLY)
	int readTimerWidth();              // get the PWM timer width (ESP32 ONLY)
	void setPeriodHertz(int hertz){
		REFRESH_CPS=hertz;
		setTimerWidth(this->timer_width);
	}
private:
	int usToTicks(int usec);
	int ticksToUs(int ticks);
//   static int ServoCount;                             // the total number of attached servos
//   static int ChannelUsed[];                          // used to track whether a channel is in service
//   int servoChannel = 0;                              // channel number for this servo

	int min = DEFAULT_uS_LOW;           // minimum pulse width for this servo
	int max = DEFAULT_uS_HIGH;            // maximum pulse width for this servo
	int pinNumber = 0;                      // GPIO pin assigned to this channel
	int timer_width = DEFAULT_TIMER_WIDTH; // ESP32 allows variable width PWM timers
	int ticks = DEFAULT_PULSE_WIDTH_TICKS; // current pulse width on this channel
	int timer_width_ticks = DEFAULT_TIMER_WIDTH_TICKS; // no. of ticks at rollover; varies with width
	ESP32PWM * getPwm(); // get the PWM object
	ESP32PWM pwm;
	int REFRESH_CPS = 50;

};
#endif

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\.pio\libdeps\upesy_wroom\ESP32Servo\src\ESP32Servo.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Actuator.h ---

/**
 * @file Actuator.h
 *
 * @brief Dichiarazione delle classi per la gestione degli attuatori.
 */
#ifndef ACTUATOR_H
#define ACTUATOR_H

#include <ESP32Servo.h>

class Actuator
{
protected:
    Servo actuator; ///< Oggetto Servo associato all'attuatore.
    int pin;        ///< Pin associato all'attuatore.
    int pwm_min, pwm_max, pwm_null;
    double digital_min, digital_max;

public:
    /**
     * @brief Costruttore della classe Actuator.
     *
     * @param pin Pin associato all'attuatore.
     */
    explicit Actuator(int pin, int pwm_min, int pwm_max, int pwm_null, double digital_min, double digital_max);

    /**
     * @brief Imposta il valore del segnale PWM per l'attuatore.
     *
     * @param value Valore del segnale PWM (0-1).
     */
    void write(double value);
};


#endif // ACTUATOR_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Actuator.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Aircraft.h ---

/**
 * @file Aircraft.h
 * @brief Dichiarazione della classe Aircraft per la gestione dei componenti hardware dell'aereo.
 */

#ifndef AIRCRAFT_H
#define AIRCRAFT_H

#include "DataStructures.h"
#include "IMU.h"
#include "Receiver.h"
#include "LED.h"
#include "Actuator.h"

/**
 * @brief Classe principale per la gestione dell'aereo.
 *
 * Incapsula i componenti hardware principali (ESC, motori, LED, IMU, ricevitore)
 * e fornisce metodi per la lettura dei sensori e il controllo degli attuatori.
 */
class Aircraft
{
private:
    Actuator esc, servo_x, servo_y, servo_z; ///< Servomotori per il controllo delle superfici di controllo.
    Receiver receiver;                       ///< Ricevitore per i comandi del pilota.
    LED led_red, led_green;                  ///< LED per il feedback visivo dello stato del sistema.
    RGB_LED led_rgb;                         ///< LED RGB per il feedback visivo dello stato del sistema.

public:
    /**
     * @brief Costruttore della classe Aircraft.
     *
     * Inizializza tutti i componenti hardware associati.
     */
    Aircraft();

    /**
     * @brief Legge i dati dall'IMU.
     *
     * Aggiorna la struttura `ImuData` e rileva eventuali errori.
     *
     * @param error Riferimento alla struttura degli errori per aggiornare lo stato dell'IMU.
     */
    void read_imu(Errors &error);

    /**
     * @brief Legge i dati dal ricevitore.
     *
     * Aggiorna la struttura `ReceiverData` e rileva eventuali errori.
     *
     * @param error Riferimento alla struttura degli errori per aggiornare lo stato del ricevitore.
     * @param state Stato attuale del controller per la gestione dei failsafe.
     */
    void read_receiver(Errors &error);

    /**
     * @brief Aggiorna lo stato dei LED in base allo stato del sistema.
     *
     * @param assist_mode Modalità di assistenza attuale.
     * @param state Stato attuale del controller.
     */
    void update_leds(ASSIST_MODE assist_mode, CONTROLLER_STATE state);

    /**
     * @brief Scrive i valori sugli attuatori.
     *
     * Utilizza i dati di output per controllare i servocomandi e l'ESC.
     */
    void write_actuators();

    /**
     * @brief Aggiorna il logger dei dati.
     *
     * Se sono state effettuate letture dati, incrementa il ciclo.
     */
    void update_data_logger();

    IMU imu;                    ///< Sensore inerziale (IMU).
    ImuData imu_data;           ///< Dati letti dall'IMU.
    ReceiverData receiver_data; ///< Dati ricevuti dal pilota.
    Output output;              ///< Output per i servocomandi e l'ESC.
};

#endif // AIRCRAFT_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Aircraft.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\DataStructures.h ---

/**
 * @file DataStructures.h
 * @brief Definizione delle strutture dati e enumerazioni utilizzate nel sistema.
 */
#ifndef DATA_STRUCTURES_H
#define DATA_STRUCTURES_H

#include "HardwareParameters.h"

/** @defgroup Enumerations Enumerazioni
 *  Enumerazioni utilizzate nel sistema.
 *  @{
 */

/**
 * @brief Enumerazione per i colori disponibili per i LED.
 */
enum class COLOR
{
    RED,        ///< Rosso.
    GREEN,      ///< Verde.
    BLUE,       ///< Blu.
    LIGHT_BLUE, ///< Blu chiaro.
    WHITE,      ///< Bianco.
    PURPLE,     ///< Viola.
    NONE        ///< Nessun colore (spento).
};

/**
 * @brief Enumerazione per gli stati del LED.
 */
enum class LED_STATE
{
    ON,   ///< LED acceso.
    OFF,  ///< LED spento.
    BLINK ///< LED lampeggiante.
};

/**
 * @brief Enumerazione per gli stati del controller.
 */
enum class CONTROLLER_STATE
{
    FAILSAFE = -1, ///< Modalità failsafe.
    DISARMED = 0,  ///< Sistema disarmato.
    ARMED = 1,     ///< Sistema armato.
};

/**
 * @brief Enumerazione per le modalità di controllo.
 */
enum class CONTROLLER_MODE
{
    STANDARD = 0,   ///< Modalità standard.
    KP_CALIBRATION, ///< Calibrazione del guadagno proporzionale.
    KI_CALIBRATION, ///< Calibrazione del guadagno integrale.
    KD_CALIBRATION  ///< Calibrazione del guadagno derivativo.
};

/**
 * @brief Enumerazione per gli assi target della calibrazione PID.
 */
enum class CALIBRATION_TARGET
{
    X, ///< Asse X.
    Y, ///< Asse Y.
    Z  ///< Asse Z.
};

/**
 * @brief Enumerazione per le modalità di assistenza.
 */
enum class ASSIST_MODE
{
    MANUAL = 0,           ///< Modalità manuale.
    GYRO_STABILIZED = 1,  ///< Stabilizzazione tramite giroscopio.
    ATTITUDE_CONTROL = 2, ///< Controllo dell'attitudine.
};

/**
 * @brief Enumerazione per i livelli di log disponibili.
 */
enum class LogLevel
{
    ERROR,   ///< Errore critico.
    WARNING, ///< Avvertimento.
    INFO,    ///< Informazione.
};

/** @} */

/** @defgroup Structures Strutture
 *  Strutture dati utilizzate nel sistema.
 *  @{
 */

/**
 * @struct Euler
 * @brief Rappresenta un vettore Euler (rollio, beccheggio, imbardata).
 */
struct Euler
{
    float x; ///< Componente X (rollio).
    float y; ///< Componente Y (beccheggio).
    float z; ///< Componente Z (imbardata).
};

/**
 * @struct Quaternion
 * @brief Rappresenta un quaternione.
 */
struct Quaternion
{
    float w; ///< Componente scalare.
    float x; ///< Componente X (i).
    float y; ///< Componente Y (j).
    float z; ///< Componente Z (k).
};

/**
 * @struct PID
 * @brief Contiene i parametri di un PID controller.
 */
struct PID
{
    float kp;           ///< Guadagno proporzionale.
    float ki;           ///< Guadagno integrale.
    float kd;           ///< Guadagno derivativo.
    float max_integral; ///< Limite massimo per l'integrale.
};

/**
 * @struct Output
 * @brief Contiene gli output sui tre assi.
 */
struct Output
{
    float x;        ///< Output per l'asse X.
    float y;        ///< Output per l'asse Y.
    float z;        ///< Output per l'asse Z.
    float throttle; ///< Output per il throttle.
};

/**
 * @struct ImuData
 * @brief Contiene i dati letti dall'IMU.
 */
struct ImuData
{
    Euler gyro;      ///< Velocità angolari (giroscopio).
    Euler accel;     ///< Accelerazioni lineari.
    Quaternion quat; ///< Orientamento (quaternione).
    float vel;       ///< Velocità integrata.
};

/**
 * @struct ReceiverData
 * @brief Contiene i dati ricevuti dal pilota.
 */
struct ReceiverData
{
    float x;        ///< Input per il rollio.
    float y;        ///< Input per il beccheggio.
    float throttle; ///< Input per il throttle.
    float z;        ///< Input per lo yaw.
    float swa;      ///< Input per lo switch A.
    float swb;      ///< Input per lo switch B.
    float swc;      ///< Input per lo switch C.
    float swd;      ///< Input per lo switch D.
    float vra;      ///< Input per il potenziometro A.
    float vrb;      ///< Input per il potenziometro B.
};

/**
 * @struct Errors
 * @brief Rappresenta gli errori di sistema.
 */
struct Errors
{
    bool RECEIVER_ERROR; ///< Errore sul pilota.
    bool IMU_ERROR;      ///< Errore sull'IMU.
};

/** @} */

#endif // DATA_STRUCTURES_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\DataStructures.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\FlightController.h ---

/**
 * @file FlightController.h
 * @brief Dichiarazione della classe FlightController per la gestione del controllo di volo.
 */

#ifndef FLIGHT_CONTROLLER_H
#define FLIGHT_CONTROLLER_H

#include "PIDcontroller.h"
#include "DataStructures.h"
#include "FlightControllerConfig.h"

/**
 * @brief Classe per la gestione del controller di volo.
 * 
 * Si occupa della logica di controllo di volo, includendo il calcolo dei PID per la stabilizzazione
 * e l'attitudine del velivolo.
 */
class FlightController
{
private:
    /**
     * @brief Calcola gli offset PID dinamici per il tuning.
     * 
     * @param assist_mode Modalità di assistenza corrente.
     * @param controller_mode Modalità di controllo corrente.
     * @param receiver_data Dati ricevuti dal pilota.
     */
    void compute_pid_offset(ASSIST_MODE assist_mode, CONTROLLER_MODE controller_mode, ReceiverData &receiver_data);

    /**
     * @brief Calcola l'attitudine desiderata in base agli input del pilota.
     * 
     * @param roll Rollio desiderato.
     * @param pitch Beccheggio desiderato.
     * @param yaw Imbardata desiderata.
     * @param result Quaternione risultante dell'attitudine desiderata.
     */
    void compute_desired_attitude(float roll, float pitch, float yaw, Quaternion &result);

    /**
     * @brief Calcola il controllo PID per le velocità angolari.
     * 
     * @param errors Errori angolari.
     * @param pid_offsets Offset PID dinamici.
     * @param dt Intervallo di tempo dall'ultimo ciclo.
     * @param output Struttura di output per gli attuatori.
     */
    void compute_gyro_pid(const Euler &errors, const PID &pid_offsets, double dt, Output &output);

    /**
     * @brief Calcola il controllo PID per l'attitudine.
     * 
     * @param errors Errori di attitudine (quaternione).
     * @param pid_offsets Offset PID dinamici.
     * @param dt Intervallo di tempo dall'ultimo ciclo.
     * @param output Struttura di output per gli attuatori.
     */
    void compute_attitude_pid(const Quaternion &errors, const PID &pid_offsets, double dt, Output &output);

    // Componenti logiche
    PIDcontroller pid_attitude_x; ///< PID per il controllo dell'assetto sull'asse X (rollio).
    PIDcontroller pid_attitude_y; ///< PID per il controllo dell'assetto sull'asse Y (beccheggio).
    PIDcontroller pid_attitude_z; ///< PID per il controllo dell'assetto sull'asse Z (imbardata).
    PIDcontroller pid_gyro_x;     ///< PID per il controllo della velocità angolare sull'asse X (rollio).
    PIDcontroller pid_gyro_y;     ///< PID per il controllo della velocità angolare sull'asse Y (beccheggio).
    PIDcontroller pid_gyro_z;     ///< PID per il controllo della velocità angolare sull'asse Z (imbardata).

    // Dati del controller di volo
    Euler error_gyro;               ///< Errori delle velocità angolari per ciascun asse (X, Y, Z).
    Quaternion error_attitude;      ///< Errori di attitudine calcolati come differenza tra setpoint e attitudine attuale.
    Quaternion desired_attitude;    ///< Attitudine desiderata calcolata dagli input del pilota.
    PID pid_tuning_offset_gyro;     ///< Offset dinamici per il tuning del PID delle velocità angolari.
    PID pid_tuning_offset_attitude; ///< Offset dinamici per il tuning del PID degli assetti.

    Errors error; ///< Struttura per gli errori rilevati.

public:
    /**
     * @brief Costruttore del FlightController.
     * 
     * @param receiver_data Riferimento ai dati ricevuti dal pilota.
     * @param imu_data Riferimento ai dati letti dall'IMU.
     * @param output Riferimento alla struttura di output per gli attuatori.
     */
    FlightController(ReceiverData &receiver_data, ImuData &imu_data, Output &output);

    /**
     * @brief Salva i dati di output del controller.
     * 
     * @param output Dati di output del controller.
     */
    void logData(const Output &output);

    /**
     * @brief Elabora i dati per la stabilizzazione del volo.
     * 
     * @param dt Intervallo di tempo dall'ultimo ciclo.
     * @param receiver_data Dati ricevuti dal pilota.
     * @param imu_data Dati letti dall'IMU.
     * @param output Struttura di output per gli attuatori.
     * @param assist_mode Modalità di assistenza corrente.
     * @param state Stato del controller.
     * @param error Errori attuali.
     * @param controller_mode Modalità di controllo corrente.
     */
    void compute_data(double dt, ReceiverData &receiver_data, ImuData &imu_data, Output &output, ASSIST_MODE assist_mode, CONTROLLER_STATE state, Errors error, CONTROLLER_MODE controller_mode);

    /**
     * @brief Esegue il controllo del velivolo.
     * 
     * @param dt Intervallo di tempo dall'ultimo ciclo.
     * @param imu_data Dati letti dall'IMU.
     * @param receiver_data Dati ricevuti dal pilota.
     * @param output Struttura di output per gli attuatori.
     * @param assist_mode Modalità di assistenza corrente.
     * @param state Stato del controller.
     * @param calibration_target Asse target per la calibrazione PID.
     */
    void control(double dt, ImuData &imu_data, ReceiverData &receiver_data, Output &output, ASSIST_MODE assist_mode, CONTROLLER_STATE state, CALIBRATION_TARGET calibration_target);
};

#endif // FLIGHT_CONTROLLER_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\FlightController.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\FlightControllerConfig.h ---

/**
 * @file FlightControllerConfig.h
 * @brief Configurazioni per i parametri PID e altre impostazioni del controllo di volo.
 */

#ifndef FLIGHT_CONTROLLER_CONFIG_H
#define FLIGHT_CONTROLLER_CONFIG_H

/**
 * @brief Configurazioni del controller di volo.
 *
 * Questo file contiene le definizioni di macro per i parametri PID, limiti e altri valori di configurazione
 * utilizzati nel sistema.
 */

/** @defgroup PID_Parameters Parametri PID
 *  @{
 */

// Parametri PID per il controllo dell'assetto (attitude)
#define KP_ATTITUDE_X 0 ///< Guadagno proporzionale per l'asse X (rollio).
#define KI_ATTITUDE_X 0 ///< Guadagno integrale per l'asse X (rollio).
#define KD_ATTITUDE_X 0 ///< Guadagno derivativo per l'asse X (rollio).

#define KP_ATTITUDE_Y 0 ///< Guadagno proporzionale per l'asse Y (beccheggio).
#define KI_ATTITUDE_Y 0 ///< Guadagno integrale per l'asse Y (beccheggio).
#define KD_ATTITUDE_Y 0 ///< Guadagno derivativo per l'asse Y (beccheggio).

#define KP_ATTITUDE_Z 0 ///< Guadagno proporzionale per l'asse Z (imbardata).
#define KI_ATTITUDE_Z 0 ///< Guadagno integrale per l'asse Z (imbardata).
#define KD_ATTITUDE_Z 0 ///< Guadagno derivativo per l'asse Z (imbardata).

// Parametri PID per il controllo della velocità angolare (gyro)
#define KP_GYRO_X 0 ///< Guadagno proporzionale per l'asse X (rollio).
#define KI_GYRO_X 0 ///< Guadagno integrale per l'asse X (rollio).
#define KD_GYRO_X 0 ///< Guadagno derivativo per l'asse X (rollio).

#define KP_GYRO_Y 0 ///< Guadagno proporzionale per l'asse Y (beccheggio).
#define KI_GYRO_Y 0 ///< Guadagno integrale per l'asse Y (beccheggio).
#define KD_GYRO_Y 0 ///< Guadagno derivativo per l'asse Y (beccheggio).

#define KP_GYRO_Z 0 ///< Guadagno proporzionale per l'asse Z (imbardata).
#define KI_GYRO_Z 0 ///< Guadagno integrale per l'asse Z (imbardata).
#define KD_GYRO_Z 0 ///< Guadagno derivativo per l'asse Z (imbardata).

/** @} */

/** @defgroup Limits Limiti e soglie
 *  @{
 */

#define MAX_INTEGRAL_ATTITUDE 0 ///< Limite massimo per il valore integrale dell'attitudine.
#define MAX_INTEGRAL_GYRO 0     ///< Limite massimo per il valore integrale del gyro.
#define MAX_INTEGRAL_ANGLE 0    ///< Limite massimo per l'angolo calcolato dai PID.

#define PID_MAX_OFFSET 2 ///< Offset massimo per il tuning PID.

#define TUNING_TARGET_AXIS 0 ///< Asse target per il tuning (0 = X, 1 = Y, 2 = Z).

#define FORWARD_SPEED_THRESHOLD 1  ///< Soglia della velocità in avanti per la riduzione del controllo.
#define SERVO_REDUCTION_FACTOR 0.5 ///< Fattore di riduzione per i servo.

#define AUTO_LAND_X 0        ///< Posizione automatica per il rollio in modalità di atterraggio.
#define AUTO_LAND_Y 6        ///< Posizione automatica per il beccheggio in modalità di atterraggio.
#define AUTO_LAND_THROTTLE 0 ///< Valore del throttle in modalità di atterraggio.
#define AUTO_LAND_Z 0        ///< Posizione automatica per lo yaw in modalità di atterraggio.

/** @} */

#endif // FLIGHT_CONTROLLER_CONFIG_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\FlightControllerConfig.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\HardwareParameters.h ---

/**
 * @file HardwareParameters.h
 * @brief Definizione dei limiti e dei parametri hardware del sistema.
 */

#ifndef HARDWARE_PARAMETERS_H
#define HARDWARE_PARAMETERS_H

/**
 * @brief Parametri hardware del sistema.
 *
 * Questo file contiene le definizioni di macro relative ai limiti hardware
 * e ai valori utilizzati per configurare il sistema.
 */

#define ESC_PWM_CHANNEL 0 ///< Canale PWM utilizzato per l'ESC.

#define RGB_RED_PWM_CHANNEL 1   ///< Canale PWM utilizzato per il LED rosso.
#define RGB_GREEN_PWM_CHANNEL 2 ///< Canale PWM utilizzato per il LED verde.
#define RGB_BLUE_PWM_CHANNEL 3  ///< Canale PWM utilizzato per il LED blu.

#define SERVO_X_PWM_CHANNEL 4 ///< Canale PWM utilizzato per il servomotore X.
#define SERVO_Y_PWM_CHANNEL 5 ///< Canale PWM utilizzato per il servomotore Y.
#define SERVO_Z_PWM_CHANNEL 6 ///< Canale PWM utilizzato per il servomotore Z.

/** @defgroup PWM_Ranges Intervalli PWM
 *  @{
 */
#define PWM_MIN 1000 ///< Valore minimo del segnale PWM.
#define PWM_MAX 2000 ///< Valore massimo del segnale PWM.
#define PWM_MIN_SERVO 1000 ///< Valore minimo del segnale PWM per i servomotori.
#define PWM_NEUTRAL_SERVO 1500 ///< Valore neutro del segnale PWM per i servomotori.
#define PWM_MAX_SERVO 2000 ///< Valore massimo del segnale PWM per i servomotori.
/** @} */

/** @defgroup Servo_Ranges Intervalli Servo
 *  @{
 */
#define SERVO_MIN_ANGLE -90 ///< Angolo minimo per il servo.
#define SERVO_MAX_ANGLE 90  ///< Angolo massimo per il servo.
/** @} */

/** @defgroup Switch_Ranges Intervalli Switch
 *  @{
 */
#define SWITCH_MIN 0        ///< Valore minimo per gli switch.
#define SWITCH_SW_ABD_MAX 1 ///< Valore massimo per gli switch A, B e C.
#define SWITCH_SW_C_MAX 2   ///< Valore massimo per lo switch D.
/** @} */

/** @defgroup Potentiometer_Ranges Intervalli Potenziometri
 *  @{
 */
#define VRA_MIN 0   ///< Valore minimo per il potenziometro A.
#define VRA_MAX 100 ///< Valore massimo per il potenziometro A.
#define VRB_MIN 0   ///< Valore minimo per il potenziometro B.
#define VRB_MAX 2   ///< Valore massimo per il potenziometro B.
/** @} */

/** @defgroup Throttle_Ranges Intervalli Throttle
 *  @{
 */
#define THROTTLE_MIN 0   ///< Valore minimo per il throttle.
#define THROTTLE_MAX 100 ///< Valore massimo per il throttle.
/** @} */

/** @defgroup Axis_Ranges Intervalli assi di volo
 *  @{
 */
#define ROLL_MIN -90 ///< Valore minimo per il rollio.
#define ROLL_MAX 90  ///< Valore massimo per il rollio.

#define PITCH_MIN -90 ///< Valore minimo per il beccheggio.
#define PITCH_MAX 90  ///< Valore massimo per il beccheggio.

#define YAW_MIN -90 ///< Valore minimo per lo yaw.
#define YAW_MAX 90  ///< Valore massimo per lo yaw.

/** @defgroup Arm_Disarm_Parameters Parametri Arm/Disarm
 *  @{
 */
#define ARM_TOLERANCE 1 ///< Tolleranza per il comando di arm/disarm.
/** @} */

/** @defgroup LED_Timings Tempi LED
 *  @{
 */
#define BLINK_ON 1000  ///< Durata ON del lampeggio LED (millisecondi).
#define BLINK_OFF 1000 ///< Durata OFF del lampeggio LED (millisecondi).
/** @} */

#endif // HARDWARE_PARAMETERS_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\HardwareParameters.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\IMU.h ---

/**
 * @file IMU.h
 * @brief Dichiarazione della classe IMU per la gestione del sensore BNO055.
 */

#ifndef IMU_H
#define IMU_H

#include "DataStructures.h"

/**
 * @brief Classe per la gestione del sensore IMU (BNO055).
 *
 * Questa classe si occupa della configurazione e lettura dei dati dall'IMU.
 */
class IMU
{
private:
public:
  /**
   * @brief Costruttore della classe IMU.
   *
   * Inizializza e configura il sensore BNO055.
   */
  IMU();

  /**
   * @brief Salva i dati letti dall'IMU.
   *
   * @param data Dati letti dall'IMU.
   */
  void logData(const ImuData &data);

  /**
   * @brief Legge i dati dall'IMU.
   *
   * @param data Struttura che riceve i dati letti dall'IMU.
   * @return true Se la lettura ha avuto successo.
   * @return false Se si è verificato un errore durante la lettura.
   */
  bool read(ImuData &data);

  bool isSetupComplete = false;
};

#endif // IMU_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\IMU.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\LED.h ---

/**
 * @file LED.h
 * @brief Dichiarazione della classe LED per la gestione dei LED semplici e RGB.
 */

#ifndef LED_H
#define LED_H

#include "DataStructures.h"

/**
 * @brief Classe per la gestione dei LED.
 *
 * Supporta la gestione dello stato e del lampeggio per un LED.
 */
class LED
{
private:
    LED_STATE state; ///< Stato attuale del LED (ON, OFF, BLINK).
    int blink_on;    ///< Durata del periodo ON durante il lampeggio (in millisecondi).
    int blink_off;   ///< Durata del periodo OFF durante il lampeggio (in millisecondi).
    int pin;         ///< Pin associato al LED.

public:
    /**
     * @brief Costruttore della classe LED.
     *
     * Inizializza il LED con lo stato OFF.
     *
     * @param pin Pin associato al LED.
     */
    explicit LED(int pin);

    /**
     * @brief Imposta lo stato del LED.
     *
     * @param state Nuovo stato del LED.
     *
     * @note Se lo stato è OFF, il LED si spegnerà.
     * @note Se lo stato è ON, il LED si accenderà.
     */
    void set_state(LED_STATE state);

    /**
     * @brief Imposta lo stato del LED in modalità lampeggio.
     *
     * @param blink_on Durata del periodo ON durante il lampeggio (in millisecondi).
     * @param blink_off Durata del periodo OFF durante il lampeggio (in millisecondi).
     */
    void set_state(int blink_on, int blink_off);

    /**
     * @brief Aggiorna lo stato del LED.
     *
     * Gestisce il lampeggio del LED in base al tempo.
     */
    void update();
};

/**
 * @brief Classe per la gestione dei LED RGB.
 *
 * Supporta la gestione del colore e del lampeggio per un LED RGB.
 */
class RGB_LED
{
private:
    int pin_red;   ///< Pin per il LED rosso.
    int pin_green; ///< Pin per il LED verde.
    int pin_blue;  ///< Pin per il LED blu.

    LED_STATE state; ///< Stato attuale del LED (ON, OFF, BLINK).
public:
    /**
     * @brief Costruttore della classe RGB_LED
     *
     * @param pin_red Pin fisico per il rosso
     * @param pin_green Pin fisico per il verde
     * @param pin_blue Pin fisico per il blu
     */
    RGB_LED(int pin_red,int pin_green, int pin_blue);

    /**
     * @brief Imposta lo stato del LED RGB.
     *
     * @param state Nuovo stato del LED.
     *
     * @note Se lo stato è OFF, il LED si spegnerà.
     * @note Se lo stato è ON, il LED si accenderà.
     */
    void set_state(LED_STATE state);

    /**
     * @brief Imposta lo stato del LED RGB.
     *
     * @param state Nuovo stato del LED.
     * @param color Nuovo colore del LED.
     *
     * @note Se lo stato è OFF, il LED si spegnerà.
     * @note Se lo stato è ON, il LED si accenderà.
     */
    void set_state(LED_STATE state, COLOR color);

    /**
     * @brief Imposta lo stato del LED RGB in modalità lampeggio.
     *
     * @param blink_on Durata del periodo ON durante il lampeggio (in millisecondi).
     * @param blink_off Durata del periodo OFF durante il lampeggio (in millisecondi).
     * @param color Colore del LED.
     */
    void set_state(int blink_on, int blink_off, COLOR color);

    /**
     * @brief Scrive il colore del LED RGB.
     *
     * @param state Stato del LED.
     * @param color Colore del LED.
     */
    void write(bool state, COLOR color);

    /**
     * @brief Aggiorna lo stato del LED RGB.
     *
     * Gestisce il lampeggio del LED in base al tempo.
     */
    void update();

    int blink_on;  ///< Durata del periodo ON durante il lampeggio (in millisecondi).
    int blink_off; ///< Durata del periodo OFF durante il lampeggio (in millisecondi).
    COLOR color;   ///< Colore del LED.
};

#endif // LED_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\LED.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Logger.h ---

/**
 * @file Logger.h
 * @brief Dichiarazione della classe Logger per la gestione dei log di sistema e dei dati numerici.
 */
#ifndef LOGGER_H
#define LOGGER_H

#include "DataStructures.h"
#include <string>
#include <vector>
#include <mutex>
#include <deque>
#include <iostream>

/**
 * @brief Classe per la gestione dei log di sistema e dei dati numerici.
 *
 * La classe fornisce un'interfaccia per la registrazione e l'invio di log di sistema
 * e dati numerici. Implementata come Singleton.
 */
class Logger
{
private:
    Logger(); ///< Costruttore privato per garantire il Singleton.

    std::mutex mutex;                  ///< Mutex per la sincronizzazione.
    std::deque<std::string> logBuffer; ///< Buffer circolare per i log.
    size_t maxBufferSize = 100;        ///< Dimensione massima del buffer dei log.

    std::deque<std::vector<std::string>> dataBuffer; ///< Buffer per i dati numerici.
    size_t maxDataBufferSize = 2000;                  ///< Dimensione massima del buffer dei dati.
    std::vector<std::string> tempDataRow;            ///< Riga temporanea per i dati del ciclo corrente.
    size_t currentCycle = 0;                         ///< Contatore del ciclo corrente.
    std::string startTimestamp;                      ///< Timestamp di inizio raccolta dati.

    bool headerInitialized = false; ///< Indica se l'header è stato inizializzato

    static void logTask(void *param); ///< Task FreeRTOS per l'invio asincrono dei log.

public:
    static Logger &getInstance(); ///< Ottiene l'istanza Singleton.

    void startLogTask(); ///< Avvia il task di invio asincrono dei log.

    void log(LogLevel level, const std::string &message, bool sendToServer = true); ///< Registra un messaggio di log.

    std::string formatLog(LogLevel level, const std::string &message) const; ///< Formatta un messaggio di log.

    void sendLogToServer(const std::string &log); ///< Invia un log al server remoto.

    void incrementCycle(); ///< Incrementa il contatore del ciclo e prepara la riga dati.

    void logData(const std::string &varName, double value, int decimalPlaces = 3); ///< Registra un dato numerico.

    void prepareDataBuffer(); ///< Organizza i dati raccolti nel buffer principale.

    void sendDataToServer(); ///< Invia i dati raccolti al server remoto.

    void printCurrentCycleData() const; ///< Stampa i dati del ciclo corrente sulla seriale.

    ~Logger() = default; ///< Distruttore di default.
};

#endif // LOGGER_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Logger.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\PIDcontroller.h ---

/**
 * @file PIDcontroller.h
 * @brief Dichiarazione della classe PIDcontrol per la gestione del controllo PID.
 * 
 * Questa classe implementa un controllore PID con supporto per limiti dell'integrale
 * e offset dinamici per il tuning in tempo reale.
 */

#ifndef PID_CONTROLLER_H
#define PID_CONTROLLER_H

/**
 * @brief Classe per il controllo PID.
 * 
 * Fornisce un metodo per calcolare il valore di controllo PID in base agli errori
 * e ai guadagni proporzionali, integrali e derivativi.
 */
class PIDcontroller
{
private:
    double kp;          ///< Guadagno proporzionale.
    double ki;          ///< Guadagno integrale.
    double kd;          ///< Guadagno derivativo.
    double maxIntegral; ///< Limite massimo per il valore integrale.

    double integral;    ///< Accumulatore per il valore integrale.
    double lastError;   ///< Ultimo errore registrato.

public:
    /**
     * @brief Costruttore della classe PIDcontrol.
     * 
     * @param kp Guadagno proporzionale iniziale.
     * @param ki Guadagno integrale iniziale.
     * @param kd Guadagno derivativo iniziale.
     * @param maxIntegral Limite massimo per il valore integrale.
     */
    PIDcontroller(double kp, double ki, double kd, double maxIntegral);

    /**
     * @brief Calcola il valore di controllo PID.
     * 
     * @param error Errore attuale.
     * @param dt Intervallo di tempo dall'ultimo calcolo.
     * @param kp_offset Offset dinamico per il guadagno proporzionale.
     * @param ki_offset Offset dinamico per il guadagno integrale.
     * @param kd_offset Offset dinamico per il guadagno derivativo.
     * @return Valore di controllo calcolato.
     */
    double pid(double error, double dt, double kp_offset, double ki_offset, double kd_offset);
};

#endif // PID_CONTROL_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\PIDcontroller.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\pins.h ---

/**
 * @file pins.h
 * @brief Definizione dei pin associati ai componenti hardware.
 */

#ifndef PIN_H
#define PIN_H

/**
 * @brief Definizione dei pin utilizzati nel sistema.
 *
 * Questo file contiene le definizioni dei pin associati ai vari componenti hardware.
 */

/** @defgroup Pin_Definitions Pin Definiti
 *  @{
 */
#define IBUS_RX_PIN 18 ///< Pin RX per il protocollo iBus.

#define SERVO_PIN_X 10 ///< Pin per il servocomando sull'asse X.
#define SERVO_PIN_Y 11  ///< Pin per il servocomando sull'asse Y.
#define SERVO_PIN_Z 12 ///< Pin per il servocomando sull'asse Z.

#define ESC_PIN 13 ///< Pin per il controller elettronico ESC.

#define LED_PIN_RED 6   ///< Pin per il LED rosso.
#define LED_PIN_GREEN 7 ///< Pin per il LED verde.

#define LED_PIN_RGB_RED 15   ///< Pin per il canale rosso del LED RGB.
#define LED_PIN_RGB_GREEN 16 ///< Pin per il canale verde del LED RGB.
#define LED_PIN_RGB_BLUE 17  ///< Pin per il canale blu del LED RGB.
/** @} */

#endif // PIN_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\pins.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\prayers.h ---

/**
 * @file prayers.h
 * @brief Definizioni simboliche utilizzate per stati di emergenza.
 */

#ifndef PRAYERS_H
#define PRAYERS_H

/**
 * @brief Definizioni simboliche utilizzate in situazioni di errore o fallback.
 * 
 * Queste macro rappresentano valori predefiniti da utilizzare in stati di emergenza assoluta.
 */

/** @defgroup Prayers_Definitions Definizioni Prayers
 *  @{
 */
#define ITSRAININGMAN 0 ///< Valore simbolico predefinito per il servomotore X.
#define HALLELUJAH 5    ///< Valore simbolico predefinito per il servomotore Y.
#define HEYMAN 0        ///< Valore simbolico predefinito per il throttle.
/** @} */

#endif // PRAYERS_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\prayers.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Quaternions.h ---

/**
 * @file Quaternions.h
 * @brief Dichiarazione delle funzioni per la manipolazione dei quaternioni.
 * 
 * Questo file include le funzioni necessarie per il calcolo e la gestione dei quaternioni,
 * inclusi la moltiplicazione, la normalizzazione e il calcolo degli errori.
 */

#ifndef QUATERNIONS_H
#define QUATERNIONS_H

#include "DataStructures.h"
#include <cmath>

/**
 * @brief Array statico di assi standard per i calcoli dei quaternioni.
 */
static float axis[3][3] = {
    {1, 0, 0}, // Asse X (ROLL)
    {0, 1, 0}, // Asse Y (PITCH)
    {0, 0, 1}  // Asse Z (YAW)
};

/**
 * @brief Calcola il coniugato di un quaternione.
 */
void quaternion_conjugate(const Quaternion &q, Quaternion &q_conj)
{
    q_conj.w = q.w;
    q_conj.x = -q.x;
    q_conj.y = -q.y;
    q_conj.z = -q.z;
}

/**
 * @brief Moltiplica due quaternioni.
 */
void quaternion_multiply(const Quaternion &q1, const Quaternion &q2, Quaternion &q_result)
{
    q_result.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
    q_result.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
    q_result.y = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;
    q_result.z = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;
}

/**
 * @brief Converte un asse e un angolo in un quaternione.
 */
void quaternion_from_axis_angle(const float axis[3], float angle_deg, Quaternion &q)
{
    float angle_rad = angle_deg * M_PI / 180.0f;
    float sin_half_angle = sin(angle_rad / 2);
    q.w = cos(angle_rad / 2);
    q.x = axis[0] * sin_half_angle;
    q.y = axis[1] * sin_half_angle;
    q.z = axis[2] * sin_half_angle;
}

/**
 * @brief Normalizza un quaternione per renderlo unitario.
 */
void quaternion_normalize(Quaternion &q)
{
    float magnitude = sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);

    if (magnitude > 0.0f)
    {
        q.w /= magnitude;
        q.x /= magnitude;
        q.y /= magnitude;
        q.z /= magnitude;
    }
}

/**
 * @brief Compone una serie di quaternioni in un unico quaternione risultante.
 */
void quaternion_compose(const Quaternion *quaternions, size_t count, Quaternion &result)
{
    result = {1, 0, 0, 0}; // Quaternione unitario
    for (size_t i = 0; i < count; ++i)
    {
        Quaternion temp;
        quaternion_multiply(result, quaternions[i], temp);
        result = temp;
    }
}

/**
 * @brief Calcola l'errore tra un quaternione desiderato e quello attuale.
 */
void quaternion_error(const Quaternion &desired, const Quaternion &actual, Quaternion &error)
{
    Quaternion conjugate;
    quaternion_conjugate(actual, conjugate);
    quaternion_multiply(desired, conjugate, error);
}

#endif // QUATERNIONS_H
--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Quaternions.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Receiver.h ---

/**
 * @file Receiver.h
 * @brief Dichiarazione della classe Receiver per la gestione del ricevitore IBUS.
 */
#ifndef RECEIVER_H
#define RECEIVER_H

#include <Arduino.h>
#include "HardwareParameters.h"
#include "DataStructures.h"

/**
 * @brief Struttura dati per i dati ricevuti dal ricevitore.
 */
struct ReceiverDataRAW
{
    int16_t ch1;  ///< Rollio.
    int16_t ch2;  ///< Beccheggio.
    int16_t ch3;  ///< Throttle.
    int16_t ch4;  ///< Yaw.
    int16_t ch5;  ///< Switch A.
    int16_t ch6;  ///< Switch B.
    int16_t ch7;  ///< Switch C.
    int16_t ch8;  ///< Switch D.
    int16_t ch9;  ///< Potenziometro A.
    int16_t ch10; ///< Potenziometro B.
};

/**
 * @brief Classe per la gestione del ricevitore IBUS.
 *
 * Questa classe permette di leggere i dati inviati dal ricevitore IBUS e decodificarli.
 * I dati vengono memorizzati in una struttura `ReceiverData` per essere utilizzati dal sistema.
 *
 * La classe è implementata in modo da essere non bloccante, permettendo di leggere i dati
 * in modo asincrono rispetto al ciclo principale.
 */
class Receiver
{
private:
    static const int PACKET_SIZE = 32;    ///< Dimensione massima del pacchetto IBUS.
    static const uint8_t HEADER_1 = 0x20; ///< Primo byte dell'header del pacchetto IBUS.
    static const uint8_t HEADER_2 = 0x40; ///< Secondo byte dell'header del pacchetto IBUS.

    int rxPin;                   ///< Pin di ricezione del segnale IBUS.
    uint8_t buffer[PACKET_SIZE]; ///< Buffer per la memorizzazione del pacchetto IBUS.
    size_t bufferIndex;          ///< Indice corrente del buffer.

    /**
     * @brief Verifica e decodifica un pacchetto IBUS dal buffer.
     *
     * @return true Se il pacchetto è valido.
     * @return false Se il pacchetto è invalido.
     */
    bool decodeIBusPacket();

    /**
     * @brief Resetta il buffer del ricevitore.
     */
    void resetBuffer();

public:
    /**
     * @brief Costruttore della classe Receiver.
     *
     * Inizializza la comunicazione seriale per la lettura dei dati.
     *
     * @param rxPin Pin di ricezione del segnale IBUS.
     */
    explicit Receiver(int rxPin);

    /**
     * @brief Legge i dati dal ricevitore IBUS.
     *
     * @param data Riferimento alla struttura `ReceiverData` per memorizzare i dati letti.
     * @return true Se i dati sono stati letti correttamente.
     * @return false Se si è verificato un errore durante la lettura.
     */
    bool read(ReceiverData &data);

    /**
     * @brief Logga i dati ricevuti dal ricevitore.
     *
     * @param data Dati ricevuti dal ricevitore.
     */
    void logData(const ReceiverData &data);
};

#endif // RECEIVER_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\Receiver.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\SystemController.h ---

/**
 * @file SystemController.h
 * @brief Dichiarazione della classe SystemController per la gestione dello stato del sistema.
 */

#ifndef SYSTEM_CONTROLLER_H
#define SYSTEM_CONTROLLER_H

#include "DataStructures.h"

/**
 * @brief Classe per la gestione del sistema di controllo.
 *
 * Si occupa di monitorare lo stato del controller, verificare le condizioni di armamento/disarmamento
 * e aggiornare le modalità operative in base agli input del pilota.
 */
class SystemController
{
private:
    /**
     * @brief Avvia il sistema, portandolo in stato armato.
     */
    void start();

    /**
     * @brief Ferma il sistema, portandolo in stato disarmato.
     */
    void stop();

    /**
     * @brief Attiva la modalità di assistenza selezionata.     *
     */
    void failSafe();

    /**
     * @brief Verifica se sono soddisfatte le condizioni per disarmare il sistema.
     *
     * @param receiver_data Dati ricevuti dal pilota.
     * @return true Se le condizioni di disarmo sono soddisfatte.
     * @return false Altrimenti.
     */
    bool check_disarm_conditions(ReceiverData &receiver_data);

    /**
     * @brief Verifica se sono soddisfatte le condizioni per armare il sistema.
     *
     * @param receiver_data Dati ricevuti dal pilota.
     * @return true Se le condizioni di armamento sono soddisfatte.
     * @return false Altrimenti.
     */
    bool check_arm_conditions(ReceiverData &receiver_data);

public:
    /**
     * @brief Costruttore della classe SystemController.
     *
     * Inizializza lo stato del controller e i parametri di configurazione.
     */
    SystemController();

    /**
     * @brief Verifica e gestisce eventuali errori nel sistema.
     */
    void check_errors();

    /**
     * @brief Avvia o ferma il sistema in base alle condizioni di armamento/disarmamento.
     */
    void update_state(ReceiverData &receiver_data);

    /**
     * @brief Aggiorna le modalità operative del controller.
     *
     * Aggiorna lo stato del sistema in base agli input ricevuti dal pilota.
     *
     * @param receiver_data Dati ricevuti dal pilota.
     */
    void update_modes(ReceiverData &receiver_data, bool imuSetupComplete);

    /**
     * @brief Imposta i valori di output per gli attuatori.
     *
     * Aggiorna l'output in base allo stato e alla modalità operativa.
     *
     * @param output Riferimento alla struttura di output da aggiornare.
     * @param receiver_data Dati ricevuti dal pilota.
     */
    void set_output(Output &output, ReceiverData &receiver_data, bool imuSetupComplete);

    // Stati del controllore
    CONTROLLER_STATE state;                ///< Stato attuale del controller.
    ASSIST_MODE assist_mode;               ///< Modalità di assistenza corrente.
    CONTROLLER_MODE controller_mode;       ///< Modalità di controllo corrente.
    CALIBRATION_TARGET calibration_target; ///< Asse target per la calibrazione PID.
    Errors error;                          ///< Errori del sistema.
};

#endif // SYSTEM_CONTROLLER_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\SystemController.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\WiFiManager.h ---

/**
 * @file WiFiManager.h
 * @brief Dichiarazione della classe WiFiManager per la gestione della connessione WiFi.
 */
#ifndef WIFI_MANAGER_H
#define WIFI_MANAGER_H

#include <WiFi.h>
#include <ESPmDNS.h>

/**
 * @brief Classe per la gestione della connessione WiFi.
 *
 * Questa classe fornisce metodi per la connessione al WiFi, la scoperta del server tramite mDNS
 * e il controllo dello stato della connessione.
 */
class WiFiManager
{
public:
    static WiFiManager &getInstance(); // Ottiene l'istanza del WiFiManager

    /**
     * @brief Inizializza la connessione WiFi in modo asincrono.
     *
     * @param ssid SSID della rete WiFi.
     * @param password Password della rete WiFi.
     */
    void begin(const char *ssid, const char *password);

    /**
     * @brief Cerca un server mDNS.
     *
     * @param serverName Nome del server da cercare.
     */
    void discoverServer(const char *serverName);

    /**
     * @brief Verifica se il server è attivo.
     *
     * @return true se il server è attivo, false altrimenti.
     */
    bool isServerActive();

    /**
     * @brief Avvia un task per gestire la connessione WiFi in modo asincrono.
     */
    void startConnectionTask();

    /**
     * @brief Avvia un task per il controllo dello stato del server.
     */
    void startServerCheckTask();

    /**
     * @brief Avvia un task per la scoperta del server mDNS.
     *
     * @param serverName Nome del server da cercare.
     */
    void startServerDiscoveryTask(const char *serverName);

    String serverAddressString;          ///< Indirizzo del server come stringa.
    const char *serverAddress = nullptr; ///< Indirizzo del server.
    const char *serverName = nullptr;    ///< Nome del server.
    uint16_t serverPort = 0;             ///< Porta del server.

private:
    /**
     * @brief Costruttore della classe WiFiManager.
     *
     * Il costruttore è privato per impedire la creazione di istanze esterne.
     * L'istanza può essere ottenuta tramite il metodo `getInstance()`.
     */
    WiFiManager() = default;

    /**
     * @brief Distruttore della classe WiFiManager.
     */
    ~WiFiManager() = default;

    WiFiManager(const WiFiManager &) = delete;            ///< Costruttore di copia disabilitato.
    WiFiManager &operator=(const WiFiManager &) = delete; ///< Operatore di assegnamento disabilitato.

    /**
     * @brief Task per la gestione asincrona della connessione WiFi.
     *
     * @param param Puntatore al WiFiManager.
     */
    static void WiFiConnectionTask(void *param);

    /**
     * @brief Task per la scoperta del server mDNS.
     *
     * @param param Struttura con il puntatore al WiFiManager e il nome del server.
     */
    static void serverDiscoveryTask(void *param);

    /**
     * @brief Task per il controllo dello stato del server.
     *
     * @param param Puntatore al WiFiManager.
     */
    static void serverCheckTask(void *param);

    const char *ssid = nullptr;              ///< SSID della rete WiFi.
    const char *password = nullptr;          ///< Password della rete WiFi.
    bool wifiConnected = false;              ///< Stato della connessione WiFi.
    bool serverSet = false;                  ///< Flag per l'impostazione del server.
    bool serverStatus = false;               ///< Flag per lo stato del server.
    unsigned long checkServerInterval = 200; ///< Intervallo di controllo in millisecondi.
    unsigned long sendInterval = 200;        ///< Intervallo di invio in millisecondi.
};

#endif // WIFI_MANAGER_H

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\include\WiFiManager.h ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Actuator.cpp ---

#include "Actuator.h"
#include "HardwareParameters.h"
#include "Logger.h"
#include <Arduino.h>

/**
 * Funzione per limitare un valore all'interno di un intervallo.
 */
template <typename T>
constexpr const T &clamp(const T &value, const T &min, const T &max)
{
    return (value < min) ? min : (value > max) ? max
                                               : value;
}

/**
 * Converte un valore digitale in PWM, rispettando i limiti configurati.
 */
int digital_to_pwm(double value, double min_digital, double max_digital, int min_analog, int max_analog)
{
    return clamp(static_cast<int>(((value - min_digital) * (max_analog - min_analog) / (max_digital - min_digital)) + min_analog), min_analog, max_analog);
}

Actuator::Actuator(int pin, int pwm_min, int pwm_max, int pwm_null, double digital_min, double digital_max) : pin(pin)
{
    Logger::getInstance().log(LogLevel::INFO, "Actuator setup started.");

    this->pwm_min = pwm_min;
    this->pwm_max = pwm_max;
    this->pwm_null = pwm_null;
    this->digital_min = digital_min;
    this->digital_max = digital_max;

    actuator.attach(pin);
    actuator.writeMicroseconds(pwm_null);

    Logger::getInstance().log(LogLevel::INFO, "Actuator setup complete.");
}

void Actuator::write(double value)
{
    int pwm_value = digital_to_pwm(value, digital_min, digital_max, pwm_min, pwm_max);
    actuator.writeMicroseconds(pwm_value);
}
--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Actuator.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Aircraft.cpp ---

#include "Aircraft.h"
#include "pins.h"
#include "Logger.h"

bool imu_read = false, receiver_read = false;

// Costruttore della classe Aircraft
Aircraft::Aircraft() : esc(ESC_PIN, PWM_MIN, PWM_MAX, PWM_MIN, THROTTLE_MIN, THROTTLE_MAX),
                       servo_x(SERVO_PIN_X, PWM_MIN_SERVO, PWM_MAX_SERVO, PWM_NEUTRAL_SERVO, ROLL_MIN, ROLL_MAX),
                       servo_y(SERVO_PIN_Y, PWM_MIN_SERVO, PWM_MAX_SERVO, PWM_NEUTRAL_SERVO, PITCH_MIN, PITCH_MAX),
                       servo_z(SERVO_PIN_Z, PWM_MIN_SERVO, PWM_MAX_SERVO, PWM_NEUTRAL_SERVO, VRA_MIN, VRA_MAX),
                       imu(),
                       receiver(IBUS_RX_PIN),
                       led_red(LED_PIN_RED),
                       led_green(LED_PIN_GREEN),
                       led_rgb(LED_PIN_RGB_RED, LED_PIN_RGB_GREEN, LED_PIN_RGB_BLUE)

{
    // Inizializza i dati del sistema
    receiver_data = {0};
    Logger::getInstance().log(LogLevel::INFO, "Aircraft setup complete.");
    led_green.set_state(LED_STATE::ON);
    led_red.set_state(BLINK_ON, BLINK_OFF);
    led_rgb.set_state(BLINK_ON, BLINK_OFF, COLOR::PURPLE);
}

void Aircraft::read_imu(Errors &error)
{
    if (!imu.isSetupComplete)
        return;

    bool imu_error = !imu.read(imu_data);

    if (error.IMU_ERROR != imu_error)
        error.IMU_ERROR = imu_error;

    if (!imu_error)
        imu_read = true;
    else
        imu_read = false;
}

void Aircraft::read_receiver(Errors &error)
{
    // Legge i dati dal ricevitore e rileva eventuali errori
    bool receiver_error = !receiver.read(receiver_data);

    if (error.RECEIVER_ERROR != receiver_error)
        error.RECEIVER_ERROR = receiver_error;

    // Logga i dati ricevuti dal ricevitore
    if (!receiver_error)
        receiver_read = true;
    else
        receiver_read = false;
}

void Aircraft::update_leds(ASSIST_MODE assist_mode, CONTROLLER_STATE state)
{
    // Aggiorna il colore del LED RGB in base alla modalità di assistenza
    switch (assist_mode)
    {
    case ASSIST_MODE::MANUAL:
        led_rgb.set_state(LED_STATE::ON, COLOR::RED); // Imposta il colore rosso
        break;
    case ASSIST_MODE::GYRO_STABILIZED:
        led_rgb.set_state(LED_STATE::ON, COLOR::BLUE); // Imposta il colore blu
        break;
    case ASSIST_MODE::ATTITUDE_CONTROL:
        led_rgb.set_state(LED_STATE::ON, COLOR::PURPLE); // Imposta il colore viola
        break;
    }

    // Aggiorna lo stato dei LED in base allo stato del controller
    switch (state)
    {
    case CONTROLLER_STATE::ARMED:
        led_green.set_state(BLINK_ON, BLINK_OFF / 5);    // Lampeggia velocemente
        led_red.set_state(LED_STATE::OFF);               // Spento
        led_rgb.set_state(LED_STATE::ON, led_rgb.color); // Acceso con il colore corrente
        break;
    case CONTROLLER_STATE::DISARMED:
        led_green.set_state(BLINK_ON / 5, BLINK_OFF); // Lampeggia lentamente
        led_red.set_state(LED_STATE::OFF);            // Spento
        led_rgb.set_state(LED_STATE::OFF);            // Spento
        break;
    case CONTROLLER_STATE::FAILSAFE:
        led_green.set_state(LED_STATE::OFF);                                   // Spento
        led_red.set_state(BLINK_ON / 5, BLINK_OFF / 5);                        // Lampeggia lentamente
        led_rgb.set_state(led_rgb.blink_on, led_rgb.blink_off, led_rgb.color); // Lampeggia con il colore corrente
        break;
    }

    // Aggiorna lo stato dei LED
    led_red.update();
    led_green.update();
    led_rgb.update();
}

void Aircraft::write_actuators()
{
    // Scrive i valori sugli attuatori
    servo_x.write(output.x);
    servo_y.write(output.y);
    servo_z.write(output.z);
    esc.write(output.throttle);
}

void Aircraft::update_data_logger()
{
    if (imu_read)
        imu.logData(imu_data);
    if (receiver_read)
        receiver.logData(receiver_data);
    // Aggiorna il logger dei dati
    if (imu_read || receiver_read) // Andrà cambiato con && o rivisto
    {
        Logger::getInstance().prepareDataBuffer(); // Organizza e salva i dati del ciclo
        Logger::getInstance().sendDataToServer();  // Invia i dati (se necessario)
        Logger::getInstance().incrementCycle();    // Passa al ciclo successivo
    }
}
--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Aircraft.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\ESP32_AircraftFlightController.ino ---

#include <Arduino.h>
#include "Aircraft.h"
#include "SystemController.h"
#include "FlightController.h"
#include "Logger.h"
#include "WiFiManager.h"

// Credenziali della rete Wi-Fi
bool usaReteCasa = true;                ///< Flag per l'utilizzo della rete Wi-Fi di casa
const char *ssidCasa = "TIM-19028281";  ///< SSID della rete Wi-Fi
const char *passwordCasa = "casa12345"; ///< Password della rete Wi-Fi
const char *ssidTelefono = "HONOR200";
const char *passwordTelefono = "moltobella";
const char *ssid = usaReteCasa ? ssidCasa : ssidTelefono;             ///< SSID della rete Wi-Fi
const char *password = usaReteCasa ? passwordCasa : passwordTelefono; ///< Password della rete Wi-Fi

const char *serverName = "Fede"; ///< Nome del server mDNS

Aircraft *aircraft = nullptr;
FlightController *flightController = nullptr;

SystemController systemController = SystemController();

static unsigned long tPrev = 0;               ///< Timestamp dell'ultimo ciclo in millisecondi.
static const unsigned long loopInterval = 10; ///< Intervallo del loop in millisecondi (100 Hz).

void setup()
{
    // Inizializzazione del monitor seriale
    Serial.begin(115200);

    // Inizializzazione del logger
    Logger::getInstance().startLogTask();

    // Inizializzazione delle connessioni
    WiFiManager::getInstance().begin(ssid, password);
    WiFiManager::getInstance().startConnectionTask();                // Avvia il task di connessione
    WiFiManager::getInstance().startServerDiscoveryTask(serverName); // Avvia il task di scoperta del server
    WiFiManager::getInstance().startServerCheckTask();               // Avvia il task di controllo dello stato del server

    // Inizializzazione del sistema di controllo
    aircraft = new Aircraft();
    flightController = new FlightController(aircraft->receiver_data, aircraft->imu_data, aircraft->output);

    Logger::getInstance().log(LogLevel::INFO, "Setup complete.");
}

void loop()
{
    unsigned long t = millis();    // Ottieni il timestamp attuale
    if (t - tPrev >= loopInterval) // Verifica se è passato l'intervallo necessario
    {
        double dt = (t - tPrev) / 1000.0; // Calcola l'intervallo di tempo in secondi
        tPrev = t;                        // Aggiorna il timestamp precedente

        // Aggiorna i dati del sistema
        aircraft->read_imu(systemController.error);
        aircraft->read_receiver(systemController.error);

        // Aggiorna lo stato del sistema
        systemController.update_state(aircraft->receiver_data);
        systemController.update_modes(aircraft->receiver_data, aircraft->imu.isSetupComplete);
        systemController.check_errors();

        // Calcola e applica il controllo
        flightController->compute_data(dt, aircraft->receiver_data, aircraft->imu_data, aircraft->output, systemController.assist_mode, systemController.state, systemController.error, systemController.controller_mode);
        flightController->control(dt, aircraft->imu_data, aircraft->receiver_data, aircraft->output, systemController.assist_mode, systemController.state, systemController.calibration_target);
        systemController.set_output(aircraft->output, aircraft->receiver_data, aircraft->imu.isSetupComplete);

        // Aggiorna i componenti hardware
        aircraft->update_leds(systemController.assist_mode, systemController.state);
        aircraft->write_actuators();

        // Aggiorna il logger
        aircraft->update_data_logger();
    }
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\ESP32_AircraftFlightController.ino ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\FlightController.cpp ---

#include "FlightController.h"
#include "Quaternions.h"
#include "Logger.h"
#include <Arduino.h>

FlightController::FlightController(ReceiverData &receiver_data, ImuData &imu_data, Output &output)
    : pid_attitude_x(KP_ATTITUDE_X, KI_ATTITUDE_X, KD_ATTITUDE_X, MAX_INTEGRAL_ATTITUDE),
      pid_attitude_y(KP_ATTITUDE_Y, KI_ATTITUDE_Y, KD_ATTITUDE_Y, MAX_INTEGRAL_ATTITUDE),
      pid_attitude_z(KP_ATTITUDE_Z, KI_ATTITUDE_Z, KD_ATTITUDE_Z, MAX_INTEGRAL_ATTITUDE),
      pid_gyro_x(KP_GYRO_X, KI_GYRO_X, KD_GYRO_X, MAX_INTEGRAL_GYRO),
      pid_gyro_y(KP_GYRO_Y, KI_GYRO_Y, KD_GYRO_Y, MAX_INTEGRAL_GYRO),
      pid_gyro_z(KP_GYRO_Z, KI_GYRO_Z, KD_GYRO_Z, MAX_INTEGRAL_GYRO)
{
    // Inizializza gli errori e i parametri del controller di volo
    error_gyro = {0, 0, 0};
    error_attitude = {0, 0, 0, 0};
    desired_attitude = {1, 0, 0, 0};
    pid_tuning_offset_gyro = {0, 0, 0, 0};
    pid_tuning_offset_attitude = {0, 0, 0, 0};
    error = {0};
    Logger::getInstance().log(LogLevel::INFO, "Flight controller initialized.");
}

void FlightController::compute_pid_offset(ASSIST_MODE assist_mode, CONTROLLER_MODE controller_mode, ReceiverData &receiver_data)
{
    // Aggiorna gli offset PID dinamici in base alla modalità operativa
    PID *target_pid = nullptr;

    if (assist_mode == ASSIST_MODE::GYRO_STABILIZED)
    {
        target_pid = &pid_tuning_offset_gyro;
    }
    else if (assist_mode == ASSIST_MODE::ATTITUDE_CONTROL)
    {
        target_pid = &pid_tuning_offset_attitude;
    }

    switch (controller_mode)
    {
    case CONTROLLER_MODE::KP_CALIBRATION:
        if (target_pid->kp == receiver_data.swb)
            return;
        target_pid->kp = receiver_data.swb;
        Logger::getInstance().log(LogLevel::INFO, "Kp updated");
        break;
    case CONTROLLER_MODE::KI_CALIBRATION:
        if (target_pid->ki == receiver_data.swb)
            return;
        target_pid->ki = receiver_data.swb;
        Logger::getInstance().log(LogLevel::INFO, "Ki updated");
        break;
    case CONTROLLER_MODE::KD_CALIBRATION:
        if (target_pid->kd == receiver_data.swb)
            return;
        target_pid->kd = receiver_data.swb;
        Logger::getInstance().log(LogLevel::INFO, "Kd updated");
        break;
    default:
        break;
    }
}

void FlightController::compute_desired_attitude(float roll, float pitch, float yaw, Quaternion &result)
{
    // Calcola l'attitudine desiderata basandosi su input di rollio, beccheggio e imbardata
    Quaternion q_roll, q_pitch, q_yaw, quaternions[3];
    quaternion_from_axis_angle(axis[0], roll, q_roll);
    quaternion_from_axis_angle(axis[1], pitch, q_pitch);
    quaternion_from_axis_angle(axis[2], yaw, q_yaw);

    quaternions[0] = q_roll;
    quaternions[1] = q_pitch;
    quaternions[2] = q_yaw;
    quaternion_compose(quaternions, 3, result);
}

void FlightController::compute_data(double dt, ReceiverData &receiver_data, ImuData &imu_data,
                                    Output &output, ASSIST_MODE assist_mode,
                                    CONTROLLER_STATE state, Errors error, CONTROLLER_MODE controller_mode)
{
    if (assist_mode == ASSIST_MODE::MANUAL || error.IMU_ERROR)
    {
        return; // Nessuna elaborazione necessaria in modalità manuale o in caso di errore IMU
    }

    compute_pid_offset(assist_mode, controller_mode, receiver_data);

    if (assist_mode == ASSIST_MODE::GYRO_STABILIZED)
    {
        // Calcola gli errori angolari per la stabilizzazione giroscopica
        error_gyro.x = receiver_data.x - imu_data.gyro.x;
        error_gyro.y = receiver_data.y - imu_data.gyro.y;
        error_gyro.z = receiver_data.z - imu_data.gyro.z;
        return;
    }

    if (assist_mode == ASSIST_MODE::ATTITUDE_CONTROL)
    {
        // Calcola l'attitudine desiderata
        float roll = error.RECEIVER_ERROR ? AUTO_LAND_X : receiver_data.x;
        float pitch = error.RECEIVER_ERROR ? AUTO_LAND_Y : receiver_data.y;
        float yaw = error.RECEIVER_ERROR ? AUTO_LAND_Z : receiver_data.z;

        compute_desired_attitude(roll, pitch, yaw, desired_attitude);

        quaternion_normalize(desired_attitude);

        // Calcola l'errore tra attitudine desiderata e attuale
        quaternion_error(desired_attitude, imu_data.quat, error_attitude);
    }
}

void FlightController::compute_gyro_pid(const Euler &errors, const PID &pid_offsets, double dt,
                                        Output &output)
{
    // Calcola gli output PID per la velocità angolare
    output.x = pid_gyro_x.pid(errors.x, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
    output.y = pid_gyro_y.pid(errors.y, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
    output.z = pid_gyro_z.pid(errors.z, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
}

void FlightController::compute_attitude_pid(const Quaternion &errors, const PID &pid_offsets, double dt,
                                            Output &output)
{
    // Calcola gli output PID per l'attitudine
    float desired_gyro_x = pid_attitude_x.pid(errors.x, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
    float desired_gyro_y = pid_attitude_y.pid(errors.y, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
    float desired_gyro_z = pid_attitude_z.pid(errors.z, dt, pid_offsets.kp, pid_offsets.ki, pid_offsets.kd);
    compute_gyro_pid({desired_gyro_x, desired_gyro_y, desired_gyro_z}, pid_offsets, dt, output);
}

void FlightController::logData(const Output &output)
{
}

void FlightController::control(double dt, ImuData &imu_data, ReceiverData &receiver_data,
                               Output &output, ASSIST_MODE assist_mode,
                               CONTROLLER_STATE state, CALIBRATION_TARGET calibration_target)
{
    if (assist_mode == ASSIST_MODE::MANUAL || error.IMU_ERROR){
        output.x = receiver_data.x;
        output.y = receiver_data.y;
        output.z = receiver_data.z;
        return;
}
    if (assist_mode == ASSIST_MODE::GYRO_STABILIZED)
    {
        compute_gyro_pid(error_gyro, pid_tuning_offset_gyro, dt, output);
    }
    else if (assist_mode == ASSIST_MODE::ATTITUDE_CONTROL)
    {
        compute_attitude_pid(error_attitude, pid_tuning_offset_attitude, dt, output);
    }

    // Applica un fattore di riduzione per velocità elevate
    double forward_speed = imu_data.vel;
    double reduction_factor = 1.0;
    reduction_factor = (forward_speed > 0)
                           ? ((forward_speed <= FORWARD_SPEED_THRESHOLD)
                                  ? 1.0 - (1.0 - SERVO_REDUCTION_FACTOR) * (forward_speed / FORWARD_SPEED_THRESHOLD)
                                  : SERVO_REDUCTION_FACTOR)
                           : 1.0;

    output.x *= reduction_factor;
    output.y *= reduction_factor;
    output.z *= reduction_factor;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\FlightController.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\IMU.cpp ---

#include "IMU.h"
#include "Logger.h"
#include <Adafruit_Sensor.h>
#include <Adafruit_BNO055.h>
#include <Arduino.h>

// Inizializzazione dell'oggetto sensore BNO055
Adafruit_BNO055 bno055 = Adafruit_BNO055(55, 0x28, &Wire);

uint16_t BNO055_SAMPLERATE_DELAY_MS = 10;                                          ///< Frequenza di campionamento in millisecondi.
const double ACCEL_VEL_TRANSITION = (double)(BNO055_SAMPLERATE_DELAY_MS) / 1000.0; ///< Fattore per velocità da accelerazione.
const double ACCEL_POS_TRANSITION = 0.5 * ACCEL_VEL_TRANSITION * ACCEL_VEL_TRANSITION;
const double DEG_2_RAD = 0.01745329251; ///< Conversione da gradi a radianti.

IMU::IMU()
{
    Serial.println("IMU setup starting.");
    Logger::getInstance().log(LogLevel::INFO, "IMU setup starting.");

    if (!bno055.begin())
    {
        Logger::getInstance().log(LogLevel::ERROR, "IMU setup failed!");

        // while (1)
        //; // Entra in loop infinito se l'inizializzazione fallisce.
        Logger::getInstance().log(LogLevel::WARNING, "Continuing without IMU.");
        return;
    }
    bno055.setExtCrystalUse(true);

    isSetupComplete = true;
    Logger::getInstance().log(LogLevel::INFO, "IMU setup complete.");
}

void IMU::logData(const ImuData &data)
{
    Logger::getInstance().logData("G_X", data.gyro.x);
    Logger::getInstance().logData("G_Y", data.gyro.y);
    Logger::getInstance().logData("G_Z", data.gyro.z);

    Logger::getInstance().logData("Ac_X", data.accel.x);
    Logger::getInstance().logData("Ac_Y", data.accel.y);
    Logger::getInstance().logData("Ac_Z", data.accel.z);

    Logger::getInstance().logData("Q_W", data.quat.w);
    Logger::getInstance().logData("Q_X", data.quat.x);
    Logger::getInstance().logData("Q_Y", data.quat.y);
    Logger::getInstance().logData("Q_Z", data.quat.z);

    Logger::getInstance().logData("V", data.vel);
}

bool IMU::read(ImuData &data)
{
    // Legge i dati dai sensori dell'IMU
    imu::Vector<3> angular_velocities = bno055.getVector(Adafruit_BNO055::VECTOR_GYROSCOPE);
    imu::Quaternion quaternion = bno055.getQuat();
    sensors_event_t linearAccelData;
    sensors_event_t orientationData;

    if (bno055.getEvent(&linearAccelData, Adafruit_BNO055::VECTOR_LINEARACCEL) ||
        bno055.getEvent(&orientationData, Adafruit_BNO055::VECTOR_EULER))
    {
        return false;
    }

    // Velocità angolari
    data.gyro.x = angular_velocities.x();
    data.gyro.y = angular_velocities.y();
    data.gyro.z = angular_velocities.z();

    // Orientamento
    data.quat.w = quaternion.w();
    data.quat.x = quaternion.x();
    data.quat.y = quaternion.y();
    data.quat.z = quaternion.z();

    // Accelerazione lineare
    data.accel.x = linearAccelData.acceleration.x;
    data.accel.y = linearAccelData.acceleration.y;
    data.accel.z = linearAccelData.acceleration.z;

    // Velocità lineare
    data.vel = ACCEL_VEL_TRANSITION * linearAccelData.acceleration.x / cos(DEG_2_RAD * orientationData.orientation.x);

    // Log dei dati
    return true;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\IMU.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\LED.cpp ---

#include "LED.h"
#include "Logger.h"
#include <Arduino.h>

LED::LED(int pin)
{
    // Configurazione di un LED
    this->pin = pin;
    this->blink_on = 0;
    this->blink_off = 0;
    state = LED_STATE::OFF;
    // Inizializzazione del LED
    pinMode(pin, OUTPUT);
    digitalWrite(pin, HIGH);
    Logger::getInstance().log(LogLevel::INFO, "LED setup complete.");
}

void LED::set_state(LED_STATE state)
{
    // Se lo stato del LED è diverso da quello attuale, lo aggiorniamo
    if (this->state != state)
        this->state = state;
}

void LED::set_state(int blink_on, int blink_off)
{
    // Imposta il LED in modalità lampeggio
    if (this->state != LED_STATE::BLINK)
        this->state = LED_STATE::BLINK;
    // Aggiorna i tempi di lampeggio
    if (this->blink_on != blink_on)
        this->blink_on = blink_on;
    if (this->blink_off != blink_off)
        this->blink_off = blink_off;
}

void LED::update()
{
    unsigned long currentMillis = millis(); // Tempo corrente

    if (state == LED_STATE::OFF)
    {
        // Se il LED è spento, lo spegniamo
        digitalWrite(pin, LOW);
    }
    else if (state == LED_STATE::ON)
    {
        // Se il LED è acceso, lo accendiamo
        digitalWrite(pin, HIGH);
    }
    else if (state == LED_STATE::BLINK)
    {
        // Se il LED è in modalità lampeggio
        static unsigned long previousMillis_simple = 0; // Variabile statica unica per il LED semplice
        static bool ledState_simple = false;

        // Alterna lo stato del LED in base al tempo
        if (currentMillis - previousMillis_simple >= (ledState_simple ? blink_on : blink_off))
        {
            previousMillis_simple = currentMillis; // Aggiorna il tempo
            ledState_simple = !ledState_simple;    // Cambia lo stato del LED

            // Accende o spegne il LED a seconda dello stato
            digitalWrite(pin, ledState_simple ? HIGH : LOW);
        }
    }
}

RGB_LED::RGB_LED(int pin_red, int pin_green, int pin_blue)
    : pin_red(pin_red),
      pin_green(pin_green),
      pin_blue(pin_blue),
      state(LED_STATE::OFF),
      color(COLOR::NONE),
      blink_on(0), blink_off(0)
{
    pinMode(pin_red, OUTPUT);
    pinMode(pin_green, OUTPUT);
    pinMode(pin_blue, OUTPUT);

    // Accendi tutti i colori
    analogWrite(pin_red, 255);
    analogWrite(pin_green, 255);
    analogWrite(pin_blue, 255);
    Logger::getInstance().log(LogLevel::INFO, "RGB Light setup complete.");
}

void RGB_LED::set_state(LED_STATE state)
{
    // Se lo stato del LED RGB è diverso da quello attuale, lo aggiorniamo
    if (state == LED_STATE::OFF && this->state != LED_STATE::OFF)
        this->state = state;
}

void RGB_LED::set_state(LED_STATE state, COLOR color)
{
    // Imposta lo stato e il colore del LED RGB
    if (this->state != state && state != LED_STATE::BLINK)
        this->state = state;
    if (this->color != color)
        this->color = color;
}

void RGB_LED::set_state(int blink_on, int blink_off, COLOR color)
{
    // Imposta il LED RGB in modalità lampeggio
    if (this->state != LED_STATE::BLINK)
        this->state = LED_STATE::BLINK;
    // Aggiorna i tempi di lampeggio e il colore
    if (this->blink_on != blink_on)
        this->blink_on = blink_on;
    if (this->blink_off != blink_off)
        this->blink_off = blink_off;
    if (this->color != color)
        this->color = color;
}

void RGB_LED::write(bool on, COLOR color)
{
    // Scrive lo stato e il colore del LED
    int color_values[3] = {0, 0, 0}; // R, G, B

    // Imposta il colore del LED RGB in base al colore selezionato
    switch (color)
    {
    case COLOR::RED:
        color_values[0] = 255;
        break;
    case COLOR::GREEN:
        color_values[1] = 255;
        break;
    case COLOR::BLUE:
        color_values[2] = 255;
        break;
    case COLOR::LIGHT_BLUE:
        color_values[0] = 170;
        color_values[1] = 170;
        color_values[2] = 255;
        break;
    case COLOR::PURPLE:
        color_values[0] = 170;
        color_values[2] = 255;
        break;
    case COLOR::WHITE:
        color_values[0] = 255;
        color_values[1] = 255;
        color_values[2] = 255;
        break;
    default:
        break;
    }

    // Se lo stato è OFF, spegni tutti i canali
    if (!on)
    {
        analogWrite(pin_red, 0);
        analogWrite(pin_green, 0);
        analogWrite(pin_blue, 0);
        return;
    }

    // Scrive i valori dei colori sui rispettivi canali PWM
    analogWrite(pin_red, color_values[0]);
    analogWrite(pin_green, color_values[1]);
    analogWrite(pin_blue, color_values[2]);
}

void RGB_LED::update()
{
    unsigned long currentMillis = millis(); // Tempo corrente

    if (state == LED_STATE::OFF)
    {
        // Se il LED RGB è spento, spegniamo tutti i colori
        write(false, color);
    }
    else if (state == LED_STATE::ON)
    {
        // Se il LED RGB è acceso, scriviamo il colore attuale
        write(true, color);
    }
    else if (state == LED_STATE::BLINK)
    {
        // Se il LED RGB è in modalità lampeggio
        static unsigned long previousMillis_rgb = 0; // Variabile statica unica per il LED RGB
        static bool ledState_rgb = false;

        // Alterna lo stato del LED in base al tempo
        if (currentMillis - previousMillis_rgb >= (ledState_rgb ? blink_on : blink_off))
        {
            previousMillis_rgb = currentMillis; // Aggiorna il tempo
            ledState_rgb = !ledState_rgb;       // Cambia lo stato del LED

            // Accende o spegne il LED a seconda dello stato
            write(ledState_rgb, color);
        }
    }
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\LED.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Logger.cpp ---

#include "Logger.h"
#include "WiFiManager.h"
#include <Arduino.h>
#include <WiFi.h>
#include <HTTPClient.h>

Logger::Logger()
{
    // Costruttore vuoto
}

Logger &Logger::getInstance()
{
    static Logger instance;
    return instance;
}

void Logger::startLogTask()
{
    xTaskCreatePinnedToCore(
        logTask,   // Funzione del task
        "LogTask", // Nome del task
        4096,      // Dimensione dello stack
        this,      // Parametro passato al task
        1,         // Priorità del task
        nullptr,   // Handle del task
        1          // Core su cui eseguire il task
    );
}

void Logger::log(LogLevel level, const std::string &message, bool sendToServer)
{
    static bool bufferFull = false;
    std::lock_guard<std::mutex> lock(mutex);
    std::string formattedLog = formatLog(level, message);
    Serial.println(formattedLog.c_str());
    if (!sendToServer)
        return;
    if (logBuffer.size() >= maxBufferSize)
    {
        logBuffer.pop_front();
        if (!bufferFull)
        {
            Logger::getInstance().log(LogLevel::WARNING, "LogBuffer is full. Older logs will be discarded.");
            bufferFull = true;
        }
    }
    else
    {
        if (bufferFull)
        {
            Logger::getInstance().log(LogLevel::WARNING, "LogBuffer is no longer full.");
            bufferFull = false;
        }
    }
    logBuffer.push_back(formattedLog);
}

std::string Logger::formatLog(LogLevel level, const std::string &message) const
{
    std::string levelStr;
    switch (level)
    {
    case LogLevel::ERROR:
        levelStr = "ERROR";
        break;
    case LogLevel::WARNING:
        levelStr = "WARNING";
        break;
    case LogLevel::INFO:
        levelStr = "INFO";
        break;
    }

    unsigned long currentTime = millis();
    unsigned long seconds = (currentTime / 1000) % 60;
    unsigned long minutes = (currentTime / 60000) % 60;
    unsigned long hours = currentTime / 3600000;

    char timestamp[16];
    snprintf(timestamp, sizeof(timestamp), "%02lu:%02lu:%02lu", hours, minutes, seconds);

    return "[" + std::string(timestamp) + "] " + levelStr + ": " + message;
}

void Logger::sendLogToServer(const std::string &log)
{
    WiFiManager &wifiManager = WiFiManager::getInstance();
    const char *serverAddress = wifiManager.serverAddress;
    uint16_t serverPort = wifiManager.serverPort;

    String serverUrl = String("http://") + serverAddress + ":" + String(serverPort) + "/receive_logs";

    HTTPClient http;
    http.begin(serverUrl.c_str());
    http.addHeader("Content-Type", "text/plain");

    int httpResponseCode = http.POST(log.c_str());

    if (httpResponseCode <= 0)
    {
        Serial.println("Failed to send log to server. HTTP error: " + String(httpResponseCode));
    }

    http.end();
}

void Logger::incrementCycle()
{
    std::lock_guard<std::mutex> lock(mutex);
    currentCycle++;
}

void Logger::logData(const std::string &varName, double value, int decimalPlaces)
{
    std::lock_guard<std::mutex> lock(mutex);

    // Troncamento del valore al numero di cifre decimali specificate
    double scalingFactor = pow(10, decimalPlaces);
    value = floor(value * scalingFactor) / scalingFactor;

    // Conversione a stringa
    std::string valueStr = std::to_string(value);

    // Aggiunta della variabile e del valore alla riga temporanea
    tempDataRow.push_back(varName);  // Nome variabile
    tempDataRow.push_back(valueStr); // Valore troncato
}

void Logger::prepareDataBuffer()
{
    std::lock_guard<std::mutex> lock(mutex);

    if (tempDataRow.empty())
    {
        Logger::getInstance().log(LogLevel::ERROR, "No data to log.");
        return;
    }

    static bool bufferFull = false;

    // Se il ciclo è 0, aggiungi i nomi delle variabili
    if (currentCycle == 0)
    {
        std::vector<std::string> headerRow;
        // Aggiungi il timestamp formattato
        time_t now = time(nullptr);
        char timestamp[20];
        strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
        headerRow.push_back(timestamp);

        // Aggiungi i nomi delle variabili (ogni elemento dispari in tempDataRow)
        for (size_t i = 0; i < tempDataRow.size(); i += 2)
        {
            headerRow.push_back(tempDataRow[i]);
        }

        // Aggiungi l'header al buffer
        if (dataBuffer.size() >= maxBufferSize)
        {
            dataBuffer.pop_front();
            bufferFull = true;
        }
        dataBuffer.push_back(headerRow);
    }
    else
    {
        // Aggiungi i valori delle variabili
        std::vector<std::string> dataRow;
        dataRow.push_back(std::to_string(currentCycle)); // Numero ciclo
        for (size_t i = 1; i < tempDataRow.size(); i += 2)
        {
            dataRow.push_back(tempDataRow[i]); // Valori delle variabili
        }

        // Aggiungi i dati al buffer
        if (dataBuffer.size() >= maxBufferSize)
        {
            dataBuffer.pop_front();
            bufferFull = true;
        }
        dataBuffer.push_back(dataRow);
    }

    // Svuota la riga temporanea
    tempDataRow.clear();
}

void Logger::sendDataToServer()
{
    WiFiManager &wifiManager = WiFiManager::getInstance();
    const char *serverAddress = wifiManager.serverAddress;
    uint16_t serverPort = wifiManager.serverPort;

    String serverUrl = String("http://") + serverAddress + ":" + String(serverPort) + "/receive_data";

    if (dataBuffer.empty())
        return;

    std::vector<std::string> row;

    {
        std::lock_guard<std::mutex> lock(mutex);
        row = dataBuffer.front();
    }

    String jsonData = "[";
    for (size_t i = 0; i < row.size(); ++i)
    {
        jsonData += "\"" + String(row[i].c_str()) + "\"";
        if (i < row.size() - 1)
            jsonData += ",";
    }
    jsonData += "]";

    HTTPClient http;
    http.begin(serverUrl.c_str());
    http.addHeader("Content-Type", "application/json");

    int httpResponseCode = http.POST(jsonData);

    if (httpResponseCode > 0)
    {
        std::lock_guard<std::mutex> lock(mutex);
        dataBuffer.pop_front();
    }
    else
    {
        String response = "Failed to send data logs to server. HTTP error: " + String(httpResponseCode);
        Logger::getInstance().log(LogLevel::ERROR, response.c_str());
    }

    http.end();
}

void Logger::printCurrentCycleData() const
{
    std::lock_guard<std::mutex> lock(const_cast<std::mutex &>(mutex));
    for (const auto &cell : tempDataRow)
    {
        Serial.print(cell.c_str());
        Serial.print("\t");
    }
    Serial.println();
}

void Logger::logTask(void *param)
{
    Logger *logger = static_cast<Logger *>(param);

    while (true)
    {
        if (WiFiManager::getInstance().isServerActive())
        {
            // Invio dei log
            std::string logMessage;

            {
                std::lock_guard<std::mutex> lock(logger->mutex);
                if (!logger->logBuffer.empty())
                {
                    logMessage = logger->logBuffer.front();
                    logger->logBuffer.pop_front();
                }
            }

            if (!logMessage.empty())
            {
                logger->sendLogToServer(logMessage);
            }

            // Invio dei dati
            logger->sendDataToServer();
        }

        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Logger.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\PIDcontroller.cpp ---

#include "PIDcontroller.h"
#include "Logger.h"
#include <Arduino.h>

PIDcontroller::PIDcontroller(double kp, double ki, double kd, double maxIntegral) : kp(kp), ki(ki), kd(kd), maxIntegral(maxIntegral)
{
    // Inizializza i parametri del PID
    integral = 0;  ///< Inizializza il valore integrale accumulato.
    lastError = 0; ///< Inizializza l'ultimo errore registrato.
    Logger::getInstance().log(LogLevel::INFO, "PID controller initialized.");
}

double PIDcontroller::pid(double error, double dt, double kp_offset, double ki_offset, double kd_offset)
{
    // Calcolo del termine integrale con limitazione
    integral += error * dt;
    if (integral > maxIntegral)
        integral = maxIntegral;
    else if (integral < -maxIntegral)
        integral = -maxIntegral;

    // Calcolo del termine derivativo
    double derivative = (error - lastError) / dt;
    lastError = error;

    // Calcolo del valore di controllo PID
    return (kp + kp_offset) * error +
           (ki + ki_offset) * integral +
           (kd + kd_offset) * derivative;
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\PIDcontroller.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Receiver.cpp ---

#include "Receiver.h"
#include "Logger.h"

Receiver::Receiver(int rxPin) : rxPin(rxPin), bufferIndex(0)
{
    Serial1.begin(115200, SERIAL_8N1, rxPin, -1); // Configura UART solo per RX
    resetBuffer();
    Logger::getInstance().log(LogLevel::INFO, "Receiver setup complete.");
}

void Receiver::resetBuffer()
{
    bufferIndex = 0;
    memset(buffer, 0, PACKET_SIZE);
}

bool Receiver::decodeIBusPacket()
{
    if (buffer[0] != HEADER_1 || buffer[1] != HEADER_2)
        return false;

    // Calcola il checksum
    uint16_t checksum = 0xFFFF;
    for (int i = 0; i < 30; ++i)
    {
        checksum -= buffer[i];
    }

    uint16_t receivedChecksum = buffer[30] | (buffer[31] << 8);
    if (checksum != receivedChecksum)
        return false;

    return true;
}

/**
 * @brief Converte un valore PWM in un valore normalizzato digitale.
 * 
 * @param pwm_value Valore PWM ricevuto.
 * @param min_analog Valore minimo PWM.
 * @param max_analog Valore massimo PWM.
 * @param min_digital Valore minimo normalizzato.
 * @param max_digital Valore massimo normalizzato.
 * 
 * @return double Valore normalizzato.
 */
double pwmToDigital(int pwm_value, int min_analog, int max_analog, double min_digital, double max_digital)
{
    double digital_value = ((double)(pwm_value - min_analog) / (max_analog - min_analog)) * (max_digital - min_digital) + min_digital;
    return (digital_value < min_digital) ? min_digital : (digital_value > max_digital) ? max_digital
                                                                                       : digital_value;
}

bool Receiver::read(ReceiverData &data)
{
    while (Serial1.available() > 0)
    {
        size_t bytesToRead = Serial1.available();
        if (bytesToRead > PACKET_SIZE - bufferIndex)
            bytesToRead = PACKET_SIZE - bufferIndex; // Non superare lo spazio disponibile nel buffer

        size_t bytesRead = Serial1.readBytes(buffer + bufferIndex, bytesToRead);
        bufferIndex += bytesRead;

        // Gestire pacchetti completi
        while (bufferIndex >= PACKET_SIZE)
        {
            if (decodeIBusPacket())
            {
                // Decodifica dati
                for (int i = 0; i < 10; ++i)
                {
                    int16_t pwm_value = buffer[2 + i * 2] | (buffer[3 + i * 2] << 8);
                    if (pwm_value < 0)
                    {
                        resetBuffer(); // Ripristina il buffer in caso di valori errati
                        return false;
                    }

                    switch (i)
                    {
                    case 0:
                        data.x = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, ROLL_MIN, ROLL_MAX);
                        break;
                    case 1:
                        data.y = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, PITCH_MIN, PITCH_MAX);
                        break;
                    case 2:
                        data.throttle = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, THROTTLE_MIN, THROTTLE_MAX);
                        break;
                    case 3:
                        data.z = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, YAW_MIN, YAW_MAX);
                        break;
                    case 4:
                        data.swa = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, SWITCH_MIN, SWITCH_SW_ABD_MAX);
                        break;
                    case 5:
                        data.swb = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, SWITCH_MIN, SWITCH_SW_ABD_MAX);
                        break;
                    case 6:
                        data.swc = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, SWITCH_MIN, SWITCH_SW_C_MAX);
                        break;
                    case 7:
                        data.swd = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, SWITCH_MIN, SWITCH_SW_ABD_MAX);
                        break;
                    case 8:
                        data.vra = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, VRA_MIN, VRA_MAX);
                        break;
                    case 9:
                        data.vrb = pwmToDigital(pwm_value, PWM_MIN, PWM_MAX, VRB_MIN, VRB_MAX);
                        break;
                    }
                }

                resetBuffer();
                return true;
            }
            else
            {
                // Rimuovere il primo byte dal buffer e spostare gli altri
                memmove(buffer, buffer + 1, --bufferIndex);
            }
        }
    }

    // Se il buffer non contiene pacchetti validi, resettalo
    resetBuffer();
    return false; // Nessun pacchetto valido letto
}

void Receiver::logData(const ReceiverData &data)
{
    Logger::getInstance().logData("x", data.x);
    Logger::getInstance().logData("y", data.y);
    Logger::getInstance().logData("throttle", data.throttle);
    Logger::getInstance().logData("z", data.z);
    Logger::getInstance().logData("swa", data.swa);
    Logger::getInstance().logData("swb", data.swb);
    Logger::getInstance().logData("swc", data.swc);
    Logger::getInstance().logData("swd", data.swd);
    Logger::getInstance().logData("vra", data.vra);
    Logger::getInstance().logData("vrb", data.vrb);
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\Receiver.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\SystemController.cpp ---

#include "SystemController.h"
#include "Logger.h"
#include "prayers.h"
#include <Arduino.h>

/**
 * @brief Funzione generica per verificare se un valore è in un intervallo.
 */
template <typename T, typename U, typename V>
bool isInRange(T value, U min, V max)
{
    T lower = (min <= max) ? min : max;
    T upper = (min <= max) ? max : min;

    return value >= lower && value <= upper;
}

SystemController::SystemController() : state(CONTROLLER_STATE::DISARMED),
                                       assist_mode(ASSIST_MODE::MANUAL),
                                       controller_mode(CONTROLLER_MODE::STANDARD),
                                       calibration_target(CALIBRATION_TARGET::X)
{
    // Inizializza gli stati del sistema
    error.IMU_ERROR = false;
    error.RECEIVER_ERROR = false;
    Logger::getInstance().log(LogLevel::INFO, "System controller initialized.");
}

void SystemController::start()
{
    // Porta il sistema in stato armato
    state = CONTROLLER_STATE::ARMED;
    Logger::getInstance().log(LogLevel::INFO, "Controller state set -> ARMED.");
}

void SystemController::stop()
{
    // Porta il sistema in stato disarmato
    if (state == CONTROLLER_STATE::FAILSAFE)
        Logger::getInstance().log(LogLevel::WARNING, "Failsafe mode released.");
    state = CONTROLLER_STATE::DISARMED;
    Logger::getInstance().log(LogLevel::INFO, "Controller state set -> DISARMED.");
}

void SystemController::failSafe()
{
    // Porta il sistema in stato di failsafe
    state = CONTROLLER_STATE::FAILSAFE;
    Logger::getInstance().log(LogLevel::WARNING, "Controller state set -> FAILSAFE.");
}

bool SystemController::check_disarm_conditions(ReceiverData &receiver_data)
{
    // Verifica se le condizioni per disarmare il sistema sono soddisfatte
    return isInRange(receiver_data.z, YAW_MAX, YAW_MAX - YAW_MAX * ARM_TOLERANCE * 0.01) &&
           isInRange(receiver_data.x, ROLL_MIN, ROLL_MIN + ROLL_MAX * ARM_TOLERANCE * 0.01) &&
           (state == CONTROLLER_STATE::ARMED || state == CONTROLLER_STATE::FAILSAFE);
}

bool SystemController::check_arm_conditions(ReceiverData &receiver_data)
{
    // Verifica se le condizioni per armare il sistema sono soddisfatte
    return isInRange(receiver_data.z, YAW_MIN, YAW_MIN + YAW_MAX * ARM_TOLERANCE * 0.01) &&
           isInRange(receiver_data.x, ROLL_MAX, ROLL_MAX - ROLL_MAX * ARM_TOLERANCE * 0.01) &&
           (state == CONTROLLER_STATE::DISARMED);
}

Errors error_prev = {false, false};

void SystemController::check_errors()
{
    // Gestisce gli errori rilevati nel sistema
    if (error.IMU_ERROR == error_prev.IMU_ERROR && error.RECEIVER_ERROR == error_prev.RECEIVER_ERROR || state == CONTROLLER_STATE::DISARMED)
    {
        error_prev.IMU_ERROR = error.IMU_ERROR;
        error_prev.RECEIVER_ERROR = error.RECEIVER_ERROR;
        return;
    }
    else if (!error.IMU_ERROR && !error.RECEIVER_ERROR && state == CONTROLLER_STATE::FAILSAFE)
    {
        Logger::getInstance().log(LogLevel::WARNING, "Failsafe mode released.");
        state = CONTROLLER_STATE::ARMED;
    }
    else if (error.IMU_ERROR)
    {
        Logger::getInstance().log(LogLevel::ERROR, "IMU error detected.");
        assist_mode = ASSIST_MODE::MANUAL;
        Logger::getInstance().log(LogLevel::WARNING, "Assist mode set -> Manual");
        failSafe();
    }
    else if (error.RECEIVER_ERROR && state == CONTROLLER_STATE::ARMED)
    {
        Logger::getInstance().log(LogLevel::ERROR, "Receiver error detected.");
        assist_mode = ASSIST_MODE::ATTITUDE_CONTROL;
        Logger::getInstance().log(LogLevel::WARNING, "Assist mode set -> Attitude control");
        failSafe();
    }
    error_prev.IMU_ERROR = error.IMU_ERROR;
    error_prev.RECEIVER_ERROR = error.RECEIVER_ERROR;
}

void SystemController::update_state(ReceiverData &receiver_data)
{
    // Aggiorna lo stato del sistema in base alle condizioni di armamento e disarmo
    if ((receiver_data.throttle >= THROTTLE_MIN && receiver_data.throttle <= THROTTLE_MIN + THROTTLE_MAX * ARM_TOLERANCE * 0.01) &&
        -receiver_data.y >= PITCH_MIN && -receiver_data.y <= PITCH_MIN + PITCH_MAX * ARM_TOLERANCE * 0.01)
    {
        if (check_disarm_conditions(receiver_data))
        {
            stop();
            return;
        }

        if (check_arm_conditions(receiver_data))
        {
            start();
            return;
        }
    }
}

void SystemController::update_modes(ReceiverData &receiver_data, bool imuSetupComplete)
{
    if (state == CONTROLLER_STATE::FAILSAFE)
        return;

    if (state == CONTROLLER_STATE::ARMED && !imuSetupComplete)
    {
        if (assist_mode != ASSIST_MODE::MANUAL)
        {
            assist_mode = ASSIST_MODE::MANUAL;
            Logger::getInstance().log(LogLevel::WARNING, "IMU not set up. Assist mode set -> Manual");
        }
        if (controller_mode != CONTROLLER_MODE::STANDARD)
        {
            controller_mode = CONTROLLER_MODE::STANDARD;
            Logger::getInstance().log(LogLevel::WARNING, "IMU not set up. Controller mode set -> Standard");
        }
        return;
    }

    struct AssistModeMapping
    {
        int swa;
        int swb;
        ASSIST_MODE mode;
        const char *message;
    };

    struct ControllerModeMapping
    {
        int swd;
        int swc;
        CONTROLLER_MODE mode;
        const char *message;
    };

    AssistModeMapping assist_modes[] = {
        {0, -1, ASSIST_MODE::MANUAL, "Assist mode set -> Manual"},
        {1, 0, ASSIST_MODE::GYRO_STABILIZED, "Assist mode set -> Gyro stabilized"},
        {1, 1, ASSIST_MODE::ATTITUDE_CONTROL, "Assist mode set -> Attitude control"},
    };

    ControllerModeMapping controller_modes[] = {
        {0, -1, CONTROLLER_MODE::STANDARD, "Controller mode set -> Standard"},
        {1, 0, CONTROLLER_MODE::KP_CALIBRATION, "Controller mode set -> KP calibration"},
        {1, 1, CONTROLLER_MODE::KI_CALIBRATION, "Controller mode set -> KI calibration"},
        {1, 2, CONTROLLER_MODE::KD_CALIBRATION, "Controller mode set -> KD calibration"},
    };

    for (const auto &mode : assist_modes)
    {
        if (receiver_data.swa == mode.swa &&
            (mode.swb == -1 || receiver_data.swb == mode.swb) &&
            assist_mode != mode.mode)
        {
            assist_mode = mode.mode;
            Logger::getInstance().log(LogLevel::INFO, mode.message);
            break;
        }
    }

    for (const auto &mode : controller_modes)
    {
        if (receiver_data.swd == mode.swd &&
            (mode.swc == -1 || receiver_data.swc == mode.swc) &&
            controller_mode != mode.mode)
        {
            controller_mode = mode.mode;
            Logger::getInstance().log(LogLevel::INFO, mode.message);
            break;
        }
    }
}

void SystemController::set_output(Output &output, ReceiverData &receiver_data, bool imuSetupComplete)
{
    static bool critical_error = false;
    output.throttle = receiver_data.throttle;
    // Aggiorna gli output in base allo stato del sistema
    if (state == CONTROLLER_STATE::DISARMED)
    {
        output = {0, 0, 0, 0};
        return;
    }
    else if ((error.IMU_ERROR || !imuSetupComplete) && error.RECEIVER_ERROR)
    {
        output = {ITSRAININGMAN, HALLELUJAH, ITSRAININGMAN, HEYMAN};
        if(!critical_error){
            Logger::getInstance().log(LogLevel::ERROR, "Critical error detected. System halted. Prayers sent.");
            critical_error = true;
        }
        return;
    }
}

--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\SystemController.cpp ---


--- Start of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\WiFiManager.cpp ---

#include "WiFiManager.h"
#include "Logger.h"
#include <WiFiClient.h>

WiFiManager &WiFiManager::getInstance()
{
    static WiFiManager instance;
    return instance;
}

void WiFiManager::begin(const char *ssid, const char *password)
{
    this->ssid = ssid;
    this->password = password;
}

bool WiFiManager::isServerActive()
{
    return serverStatus;
}

void WiFiManager::discoverServer(const char *serverName)
{
    static bool serviceFound = true, serverOk = true;
    int n = MDNS.queryService("http", "tcp"); // Cerca un servizio HTTP su TCP

    if (n == 0)
    {
        if (serviceFound)
        {
            Logger::getInstance().log(LogLevel::WARNING, "No service found.");
            serviceFound = false;
        }
    }
    else
    {
        if (!serviceFound)
        {
            Logger::getInstance().log(LogLevel::INFO, "Service found.");
            serviceFound = true;
        }
        for (int i = 0; i < n; ++i)
        {
            if (MDNS.hostname(i) == serverName)
            {
                this->serverName = serverName;
                IPAddress ip = MDNS.IP(i);
                this->serverAddressString = ip.toString();
                this->serverAddress = this->serverAddressString.c_str();
                this->serverPort = MDNS.port(i);

                if (!serverOk)
                {
                    Logger::getInstance().log(LogLevel::INFO, "Server found.");
                    serverOk = true;
                }
                this->serverSet = true;
                return;
            }
        }
        if (serverOk)
        {
            Logger::getInstance().log(LogLevel::WARNING, "Target server not found.");
            serverOk = false;
        }
    }
}

void WiFiManager::startConnectionTask()
{
    xTaskCreatePinnedToCore(
        WiFiConnectionTask,   // Funzione del task
        "WiFiConnectionTask", // Nome del task
        4096,                 // Dimensione dello stack
        this,                 // Parametro passato al task
        1,                    // Priorità
        nullptr,              // Handle del task
        1                     // Core su cui eseguire il task
    );
}

void WiFiManager::startServerDiscoveryTask(const char *serverName)
{
    struct TaskParams
    {
        WiFiManager *manager;
        const char *serverName;
    };

    TaskParams *params = new TaskParams{this, serverName};

    xTaskCreatePinnedToCore(
        serverDiscoveryTask,   // Funzione del task
        "ServerDiscoveryTask", // Nome del task
        4096,                  // Dimensione dello stack
        params,                // Parametro passato al task
        1,                     // Priorità
        nullptr,               // Handle del task
        1                      // Core su cui eseguire il task
    );
}

void WiFiManager::startServerCheckTask()
{
    xTaskCreatePinnedToCore(
        serverCheckTask,   // Funzione del task
        "ServerCheckTask", // Nome del task
        4096,              // Dimensione dello stack
        this,              // Parametro passato al task
        1,                 // Priorità
        nullptr,           // Handle del task
        1                  // Core su cui eseguire il task
    );
}

void WiFiManager::WiFiConnectionTask(void *param)
{
    WiFiManager *manager = static_cast<WiFiManager *>(param);

    while (true)
    {
        if (WiFi.status() != WL_CONNECTED)
        {
            if (manager->wifiConnected)
                Logger::getInstance().log(LogLevel::WARNING, "WiFi connection lost.");

            manager->wifiConnected = false;

            Logger::getInstance().log(LogLevel::WARNING, "Attempting to connect to WiFi...");
            WiFi.begin(manager->ssid, manager->password);
            while (WiFi.status() != WL_CONNECTED)
                ;
            // Configura il time NTP
            Logger::getInstance().log(LogLevel::INFO, "Synchronizing time with NTP server...");
            configTime(0, 0, "pool.ntp.org");
            while (time(nullptr) < 24 * 3600)
            {
                delay(100); // Aspetta che l'ora venga sincronizzata
            }
            Logger::getInstance().log(LogLevel::INFO, "Time synchronized.");

            // Avvia il mDNS
            if (!MDNS.begin("esp32"))
            {
                Logger::getInstance().log(LogLevel::ERROR, "Error starting mDNS.");
            }
            else
            {
                Logger::getInstance().log(LogLevel::INFO, "mDNS responder started.");
            }

            manager->wifiConnected = true;
            Logger::getInstance().log(LogLevel::INFO, "Connected to WiFi.");
        }
    }
}

void WiFiManager::serverDiscoveryTask(void *param)
{
    struct TaskParams
    {
        WiFiManager *manager;
        const char *serverName;
    };

    TaskParams *params = static_cast<TaskParams *>(param);
    WiFiManager *manager = params->manager;
    const char *serverName = params->serverName;

    while (true)
    {
        if (!manager->serverSet && manager->wifiConnected)
        {
            manager->discoverServer(serverName);
        }
        else if (!manager->wifiConnected)
        {
            manager->serverSet = false;
        }
        vTaskDelay(manager->checkServerInterval / portTICK_PERIOD_MS);
    }

    delete params;
}

void WiFiManager::serverCheckTask(void *param)
{
    WiFiManager *manager = static_cast<WiFiManager *>(param);
    WiFiClient client;

    while (true)
    {
        if (!manager->wifiConnected || !manager->serverSet)
        {
            if (manager->serverStatus)
            {
                manager->serverStatus = false;
                Logger::getInstance().log(LogLevel::WARNING, "WiFi not connected. Skipping server check.");
            }
        }
        else
        {
            String serverAddress = manager->serverAddress;
            if (!serverAddress.isEmpty() && manager->serverPort > 0)
            {
                if (client.connect(manager->serverAddress, manager->serverPort))
                {
                    client.stop();
                    if (!manager->serverStatus)
                    {
                        manager->serverStatus = true;
                        Logger::getInstance().log(LogLevel::INFO, "Connection to server established.");
                    }
                }
                else
                {
                    if (manager->serverStatus)
                    {
                        manager->serverStatus = false;
                        Logger::getInstance().log(LogLevel::WARNING, "Connection to server failed.");
                    }
                }
            }
            else
            {
                manager->serverStatus = false;
            }
        }
        vTaskDelay(manager->checkServerInterval / portTICK_PERIOD_MS);
    }
}
--- End of C:\Users\feder\Documents\GitHub_Repositories\ESP32_FlightController\src\WiFiManager.cpp ---

